"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[792],{52325:function(e,t,a){var i=a(42223),n=a(80496),r=a(67060);a(67462);var o=a(42474),l=a(67172),s=a(95131),u=a(4285),d=a(37083),f=a(91094);function _interopDefaultLegacy(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function _interopNamespace(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach(function(a){if("default"!==a){var i=Object.getOwnPropertyDescriptor(e,a);Object.defineProperty(t,a,i.get?i:{enumerable:!0,get:function(){return e[a]}})}}),t.default=e,Object.freeze(t)}var c=_interopNamespace(i),m=_interopDefaultLegacy(r),h=_interopDefaultLegacy(o),g=_interopNamespace(l),w=_interopDefaultLegacy(d),b=_interopDefaultLegacy(f);let p=n.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),y=n.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617"),v=n.Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),S=n.Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function getCurveFromQ(e){let t;if(n.Scalar.eq(e,S))t=await n.buildBn128();else if(n.Scalar.eq(e,v))t=await n.buildBls12381();else throw Error(`Curve not supported: ${n.Scalar.toString(e)}`);return t}async function getCurveFromName(e){let t;let a=e.toUpperCase().match(/[A-Za-z0-9]+/g).join("");if(["BN128","BN254","ALTBN128"].indexOf(a)>=0)t=await n.buildBn128();else if(["BLS12381"].indexOf(a)>=0)t=await n.buildBls12381();else throw Error(`Curve not supported: ${e}`);return t}function log2(e){return((4294901760&e)!=0?(e&=4294901760,16):0)|((4278255360&e)!=0?(e&=4278255360,8):0)|((4042322160&e)!=0?(e&=4042322160,4):0)|((3435973836&e)!=0?(e&=3435973836,2):0)|(2863311530&e)!=0}function formatHash(e,t){let a=new DataView(e.buffer,e.byteOffset,e.byteLength),i="";for(let e=0;e<4;e++){e>0&&(i+="\n"),i+="		";for(let t=0;t<4;t++)t>0&&(i+=" "),i+=a.getUint32(16*e+4*t).toString(16).padStart(8,"0")}return t&&(i=t+"\n"+i),i}function hashIsEqual(e,t){if(e.byteLength!=t.byteLength)return!1;for(var a=new Int8Array(e),i=new Int8Array(t),n=0;n!=e.byteLength;n++)if(a[n]!=i[n])return!1;return!0}async function sameRatio$2(e,t,a,i,n){if(e.G1.isZero(t)||e.G1.isZero(a)||e.G2.isZero(i)||e.G2.isZero(n))return!1;let r=await e.pairingEq(t,n,e.G1.neg(a),i);return r}function getRandomBytes(e){let t=new Uint8Array(e);return void 0!==globalThis.crypto?globalThis.crypto.getRandomValues(t):h.default.randomFillSync(t),t}async function sha256digest(e){if(void 0===globalThis.crypto||void 0===globalThis.crypto.subtle)return h.default.createHash("sha256").update(e).digest();{let t=await globalThis.crypto.subtle.digest("SHA-256",e.buffer);return new Uint8Array(t)}}function readUInt32BE(e,t){return new DataView(e.buffer).getUint32(t,!1)}async function getRandomRng(e){for(;!e;)e=await window.prompt("Enter a random text. (Entropy): ","");let t=m.default(64);t.update(getRandomBytes(64));let a=new TextEncoder;t.update(a.encode(e));let i=t.digest(),r=[];for(let e=0;e<8;e++)r[e]=readUInt32BE(i,4*e);let o=new n.ChaCha(r);return o}async function rngFromBeaconParams(e,t){let a,i;t<32?(a=1<<t>>>0,i=1):(a=4294967296,i=1<<t-32>>>0);let r=e;for(let e=0;e<i;e++)for(let e=0;e<a;e++)r=await sha256digest(r);let o=new DataView(r.buffer,r.byteOffset,r.byteLength),l=[];for(let e=0;e<8;e++)l[e]=o.getUint32(4*e,!1);let s=new n.ChaCha(l);return s}async function writeHeader(e,t){await c.startWriteSection(e,1),await e.writeULE32(1),await c.endWriteSection(e);let a=await getCurveFromQ(t.q);await c.startWriteSection(e,2);let i=a.q,r=(Math.floor((n.Scalar.bitLength(i)-1)/64)+1)*8,o=a.r,l=(Math.floor((n.Scalar.bitLength(o)-1)/64)+1)*8;await e.writeULE32(r),await c.writeBigInt(e,i,r),await e.writeULE32(l),await c.writeBigInt(e,o,l),await e.writeULE32(t.nVars),await e.writeULE32(t.nPublic),await e.writeULE32(t.domainSize),await writeG1(e,a,t.vk_alpha_1),await writeG1(e,a,t.vk_beta_1),await writeG2(e,a,t.vk_beta_2),await writeG2(e,a,t.vk_gamma_2),await writeG1(e,a,t.vk_delta_1),await writeG2(e,a,t.vk_delta_2),await c.endWriteSection(e)}async function writeG1(e,t,a){let i=new Uint8Array(2*t.G1.F.n8);t.G1.toRprLEM(i,0,a),await e.write(i)}async function writeG2(e,t,a){let i=new Uint8Array(2*t.G2.F.n8);t.G2.toRprLEM(i,0,a),await e.write(i)}async function readG1(e,t,a){let i=await e.read(2*t.G1.F.n8),n=t.G1.fromRprLEM(i,0);return a?t.G1.toObject(n):n}async function readG2(e,t,a){let i=await e.read(2*t.G2.F.n8),n=t.G2.fromRprLEM(i,0);return a?t.G2.toObject(n):n}async function readHeader$1(e,t,a){await c.startReadUniqueSection(e,t,1);let i=await e.readULE32();if(await c.endReadSection(e),1===i)return await readHeaderGroth16(e,t,a);if(2===i)return await readHeaderPlonk(e,t,a);if(10===i)return await readHeaderFFlonk(e,t,a);throw Error("Protocol not supported: ")}async function readHeaderGroth16(e,t,a){let i={};i.protocol="groth16",await c.startReadUniqueSection(e,t,2);let n=await e.readULE32();i.n8q=n,i.q=await c.readBigInt(e,n);let r=await e.readULE32();return i.n8r=r,i.r=await c.readBigInt(e,r),i.curve=await getCurveFromQ(i.q),i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=log2(i.domainSize),i.vk_alpha_1=await readG1(e,i.curve,a),i.vk_beta_1=await readG1(e,i.curve,a),i.vk_beta_2=await readG2(e,i.curve,a),i.vk_gamma_2=await readG2(e,i.curve,a),i.vk_delta_1=await readG1(e,i.curve,a),i.vk_delta_2=await readG2(e,i.curve,a),await c.endReadSection(e),i}async function readHeaderPlonk(e,t,a){let i={};i.protocol="plonk",await c.startReadUniqueSection(e,t,2);let n=await e.readULE32();i.n8q=n,i.q=await c.readBigInt(e,n);let r=await e.readULE32();return i.n8r=r,i.r=await c.readBigInt(e,r),i.curve=await getCurveFromQ(i.q),i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=log2(i.domainSize),i.nAdditions=await e.readULE32(),i.nConstraints=await e.readULE32(),i.k1=await e.read(r),i.k2=await e.read(r),i.Qm=await readG1(e,i.curve,a),i.Ql=await readG1(e,i.curve,a),i.Qr=await readG1(e,i.curve,a),i.Qo=await readG1(e,i.curve,a),i.Qc=await readG1(e,i.curve,a),i.S1=await readG1(e,i.curve,a),i.S2=await readG1(e,i.curve,a),i.S3=await readG1(e,i.curve,a),i.X_2=await readG2(e,i.curve,a),await c.endReadSection(e),i}async function readHeaderFFlonk(e,t,a){let i={};i.protocol="fflonk",i.protocolId=10,await c.startReadUniqueSection(e,t,2);let n=await e.readULE32();i.n8q=n,i.q=await c.readBigInt(e,n),i.curve=await getCurveFromQ(i.q);let r=await e.readULE32();return i.n8r=r,i.r=await c.readBigInt(e,r),i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=log2(i.domainSize),i.nAdditions=await e.readULE32(),i.nConstraints=await e.readULE32(),i.k1=await e.read(r),i.k2=await e.read(r),i.w3=await e.read(r),i.w4=await e.read(r),i.w8=await e.read(r),i.wr=await e.read(r),i.X_2=await readG2(e,i.curve,a),i.C0=await readG1(e,i.curve,a),await c.endReadSection(e),i}async function readZKey(e,t){let{fd:a,sections:i}=await c.readBinFile(e,"zkey",1),r=await readHeader$1(a,i,t),o=new n.F1Field(r.r),l=n.Scalar.mod(n.Scalar.shl(1,8*r.n8r),r.r),s=o.inv(l),u=o.mul(s,s),d=await getCurveFromQ(r.q);await c.startReadUniqueSection(a,i,3),r.IC=[];for(let e=0;e<=r.nPublic;e++){let e=await readG1(a,d,t);r.IC.push(e)}await c.endReadSection(a),await c.startReadUniqueSection(a,i,4);let f=await a.readULE32();r.ccoefs=[];for(let e=0;e<f;e++){let e=await a.readULE32(),t=await a.readULE32(),i=await a.readULE32(),n=await readFr2();r.ccoefs.push({matrix:e,constraint:t,signal:i,value:n})}await c.endReadSection(a),await c.startReadUniqueSection(a,i,5),r.A=[];for(let e=0;e<r.nVars;e++){let i=await readG1(a,d,t);r.A[e]=i}await c.endReadSection(a),await c.startReadUniqueSection(a,i,6),r.B1=[];for(let e=0;e<r.nVars;e++){let i=await readG1(a,d,t);r.B1[e]=i}await c.endReadSection(a),await c.startReadUniqueSection(a,i,7),r.B2=[];for(let e=0;e<r.nVars;e++){let i=await readG2(a,d,t);r.B2[e]=i}await c.endReadSection(a),await c.startReadUniqueSection(a,i,8),r.C=[];for(let e=r.nPublic+1;e<r.nVars;e++){let i=await readG1(a,d,t);r.C[e]=i}await c.endReadSection(a),await c.startReadUniqueSection(a,i,9),r.hExps=[];for(let e=0;e<r.domainSize;e++){let e=await readG1(a,d,t);r.hExps.push(e)}return await c.endReadSection(a),await a.close(),r;async function readFr2(){let e=await c.readBigInt(a,r.n8r);return o.mul(e,u)}}async function readContribution$1(e,t,a){let i={delta:{}};i.deltaAfter=await readG1(e,t,a),i.delta.g1_s=await readG1(e,t,a),i.delta.g1_sx=await readG1(e,t,a),i.delta.g2_spx=await readG2(e,t,a),i.transcript=await e.read(64),i.type=await e.readULE32();let n=await e.readULE32(),r=e.pos,o=0;for(;e.pos-r<n;){let t=await e.read(1);if(t[0]<=o)throw Error("Parameters in the contribution must be sorted");if(o=t[0],1==t[0]){let t=await e.read(1),a=await e.read(t[0]);i.name=new TextDecoder().decode(a)}else if(2==t[0]){let t=await e.read(1);i.numIterationsExp=t[0]}else if(3==t[0]){let t=await e.read(1);i.beaconHash=await e.read(t[0])}else throw Error("Parameter not recognized")}if(e.pos!=r+n)throw Error("Parametes do not match");return i}async function readMPCParams(e,t,a){await c.startReadUniqueSection(e,a,10);let i={contributions:[]};i.csHash=await e.read(64);let n=await e.readULE32();for(let a=0;a<n;a++){let a=await readContribution$1(e,t);i.contributions.push(a)}return await c.endReadSection(e),i}async function writeContribution$1(e,t,a){await writeG1(e,t,a.deltaAfter),await writeG1(e,t,a.delta.g1_s),await writeG1(e,t,a.delta.g1_sx),await writeG2(e,t,a.delta.g2_spx),await e.write(a.transcript),await e.writeULE32(a.type||0);let i=[];if(a.name){i.push(1);let e=new TextEncoder("utf-8").encode(a.name.substring(0,64));i.push(e.byteLength);for(let t=0;t<e.byteLength;t++)i.push(e[t])}if(1==a.type){i.push(2),i.push(a.numIterationsExp),i.push(3),i.push(a.beaconHash.byteLength);for(let e=0;e<a.beaconHash.byteLength;e++)i.push(a.beaconHash[e])}if(i.length>0){let t=new Uint8Array(i);await e.writeULE32(t.byteLength),await e.write(t)}else await e.writeULE32(0)}async function writeMPCParams(e,t,a){await c.startWriteSection(e,10),await e.write(a.csHash),await e.writeULE32(a.contributions.length);for(let i=0;i<a.contributions.length;i++)await writeContribution$1(e,t,a.contributions[i]);await c.endWriteSection(e)}function hashG1(e,t,a){let i=new Uint8Array(2*t.G1.F.n8);t.G1.toRprUncompressed(i,0,a),e.update(i)}function hashPubKey(e,t,a){hashG1(e,t,a.deltaAfter),hashG1(e,t,a.delta.g1_s),hashG1(e,t,a.delta.g1_sx),function(e,t,a){let i=new Uint8Array(2*t.G2.F.n8);t.G2.toRprUncompressed(i,0,a),e.update(i)}(e,t,a.delta.g2_spx),e.update(a.transcript)}async function writeBin(e,t,a){await c.startWriteSection(e,1);let i=(Math.floor((n.Scalar.bitLength(a)-1)/64)+1)*8;if(await e.writeULE32(i),await c.writeBigInt(e,a,i),t.byteLength%i!=0)throw Error("Invalid witness length");await e.writeULE32(t.byteLength/i),await c.endWriteSection(e),await c.startWriteSection(e,2),await e.write(t),await c.endWriteSection(e)}async function readHeader(e,t){await c.startReadUniqueSection(e,t,1);let a=await e.readULE32(),i=await c.readBigInt(e,a),n=await e.readULE32();return await c.endReadSection(e),{n8:a,q:i,nWitness:n}}let{stringifyBigInts:C}=n.utils;async function groth16Prove(e,t,a){let{fd:i,sections:r}=await c.readBinFile(t,"wtns",2,33554432,8388608),o=await readHeader(i,r),{fd:l,sections:s}=await c.readBinFile(e,"zkey",2,33554432,8388608),u=await readHeader$1(l,s);if("groth16"!=u.protocol)throw Error("zkey file is not groth16");if(!n.Scalar.eq(u.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!=u.nVars)throw Error(`Invalid witness length. Circuit: ${u.nVars}, witness: ${o.nWitness}`);let d=u.curve,f=d.Fr,m=d.G1,h=d.G2,g=log2(u.domainSize);a&&a.debug("Reading Wtns");let w=await c.readSection(i,r,2);a&&a.debug("Reading Coeffs");let b=await c.readSection(l,s,4);a&&a.debug("Building ABC");let[p,y,v]=await buildABC1(d,u,w,b,a),S=g==f.s?d.Fr.shift:d.Fr.w[g+1],F=await f.ifft(p,"","",a,"IFFT_A"),E=await f.batchApplyKey(F,f.e(1),S),B=await f.fft(E,"","",a,"FFT_A"),x=await f.ifft(y,"","",a,"IFFT_B"),P=await f.batchApplyKey(x,f.e(1),S),L=await f.fft(P,"","",a,"FFT_B"),A=await f.ifft(v,"","",a,"IFFT_C"),T=await f.batchApplyKey(A,f.e(1),S),_=await f.fft(T,"","",a,"FFT_C");a&&a.debug("Join ABC");let G=await joinABC(d,u,B,L,_,a),R={};a&&a.debug("Reading A Points");let z=await c.readSection(l,s,5);R.pi_a=await d.G1.multiExpAffine(z,w,a,"multiexp A"),a&&a.debug("Reading B1 Points");let U=await c.readSection(l,s,6),k=await d.G1.multiExpAffine(U,w,a,"multiexp B1");a&&a.debug("Reading B2 Points");let I=await c.readSection(l,s,7);R.pi_b=await d.G2.multiExpAffine(I,w,a,"multiexp B2"),a&&a.debug("Reading C Points");let O=await c.readSection(l,s,8);R.pi_c=await d.G1.multiExpAffine(O,w.slice((u.nPublic+1)*d.Fr.n8),a,"multiexp C"),a&&a.debug("Reading H Points");let $=await c.readSection(l,s,9),V=await d.G1.multiExpAffine($,G,a,"multiexp H"),q=d.Fr.random(),Q=d.Fr.random();R.pi_a=m.add(R.pi_a,u.vk_alpha_1),R.pi_a=m.add(R.pi_a,m.timesFr(u.vk_delta_1,q)),R.pi_b=h.add(R.pi_b,u.vk_beta_2),R.pi_b=h.add(R.pi_b,h.timesFr(u.vk_delta_2,Q)),k=m.add(k,u.vk_beta_1),k=m.add(k,m.timesFr(u.vk_delta_1,Q)),R.pi_c=m.add(R.pi_c,V),R.pi_c=m.add(R.pi_c,m.timesFr(R.pi_a,Q)),R.pi_c=m.add(R.pi_c,m.timesFr(k,q)),R.pi_c=m.add(R.pi_c,m.timesFr(u.vk_delta_1,f.neg(f.mul(q,Q))));let Z=[];for(let e=1;e<=u.nPublic;e++){let t=w.slice(e*f.n8,e*f.n8+f.n8);Z.push(n.Scalar.fromRprLE(t))}return R.pi_a=m.toObject(m.toAffine(R.pi_a)),R.pi_b=h.toObject(h.toAffine(R.pi_b)),R.pi_c=m.toObject(m.toAffine(R.pi_c)),R.protocol="groth16",R.curve=d.name,await l.close(),await i.close(),{proof:R=C(R),publicSignals:Z=C(Z)}}async function buildABC1(e,t,a,i,r){let o=e.Fr.n8,l=12+t.n8r,s=(i.byteLength-4)/l,u=new n.BigBuffer(t.domainSize*o),d=new n.BigBuffer(t.domainSize*o),f=new n.BigBuffer(t.domainSize*o),c=[u,d];for(let t=0;t<s;t++){r&&t%1e6==0&&r.debug(`QAP AB: ${t}/${s}`);let n=i.slice(4+t*l,4+t*l+l),u=new DataView(n.buffer),d=u.getUint32(0,!0),f=u.getUint32(4,!0),m=u.getUint32(8,!0),h=n.slice(12,12+o);c[d].set(e.Fr.add(c[d].slice(f*o,f*o+o),e.Fr.mul(h,a.slice(m*o,m*o+o))),f*o)}for(let a=0;a<t.domainSize;a++)r&&a%1e6==0&&r.debug(`QAP C: ${a}/${t.domainSize}`),f.set(e.Fr.mul(u.slice(a*o,a*o+o),d.slice(a*o,a*o+o)),a*o);return[u,d,f]}async function joinABC(e,t,a,i,r,o){let l;let s=e.Fr.n8,u=Math.floor(a.byteLength/e.Fr.n8),d=[];for(let t=0;t<u;t+=4194304){o&&o.debug(`JoinABC: ${t}/${u}`);let n=Math.min(u-t,4194304),l=[],f=a.slice(t*s,(t+n)*s),c=i.slice(t*s,(t+n)*s),m=r.slice(t*s,(t+n)*s);l.push({cmd:"ALLOCSET",var:0,buff:f}),l.push({cmd:"ALLOCSET",var:1,buff:c}),l.push({cmd:"ALLOCSET",var:2,buff:m}),l.push({cmd:"ALLOC",var:3,len:n*s}),l.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:n},{var:3}]}),l.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:n},{var:3}]}),l.push({cmd:"GET",out:0,var:3,len:n*s}),d.push(e.tm.queueAction(l))}let f=await Promise.all(d);l=a instanceof n.BigBuffer?new n.BigBuffer(a.byteLength):new Uint8Array(a.byteLength);let c=0;for(let e=0;e<f.length;e++)l.set(f[e][0],c),c+=f[e][0].byteLength;return l}let{unstringifyBigInts:F}=n.utils;async function wtnsCalculate(e,t,a,i){let n=F(e),r=await g.readExisting(t),o=await r.read(r.totalSize);await r.close();let l=await s.WitnessCalculatorBuilder(o);if(1==l.circom_version()){let e=await l.calculateBinWitness(n),t=await c.createBinFile(a,"wtns",2,2);await writeBin(t,e,l.prime),await t.close()}else{let e=await g.createOverride(a),t=await l.calculateWTNSBin(n);await e.write(t),await e.close()}}let{unstringifyBigInts:E}=n.utils;async function groth16FullProve(e,t,a,i){let n=E(e),r={type:"mem"};return await wtnsCalculate(n,t,r),await groth16Prove(a,r,i)}let{unstringifyBigInts:B}=n.utils;async function groth16Verify(e,t,a,i){let r=B(e),o=B(a),l=B(t),s=await getCurveFromName(r.curve),u=s.G1.fromObject(r.IC[0]),d=new Uint8Array(2*s.G1.F.n8*l.length),f=new Uint8Array(s.Fr.n8*l.length);if(!function(e,t){for(let a=0;a<t.length;a++)if(!n.Scalar.lt(t[a],e.r))return!1;return!0}(s,l))return i&&i.error("Public inputs are not valid."),!1;for(let e=0;e<l.length;e++){let t=s.G1.fromObject(r.IC[e+1]);d.set(t,e*s.G1.F.n8*2),n.Scalar.toRprLE(f,s.Fr.n8*e,l[e],s.Fr.n8)}let c=await s.G1.multiExpAffine(d,f);c=s.G1.add(c,u);let m=s.G1.fromObject(o.pi_a),h=s.G2.fromObject(o.pi_b),g=s.G1.fromObject(o.pi_c);if(!function(e,t){let a=e.G1,i=e.G2;return a.isValid(t.pi_a)&&i.isValid(t.pi_b)&&a.isValid(t.pi_c)}(s,{pi_a:m,pi_b:h,pi_c:g}))return i&&i.error("Proof commitments are not valid."),!1;let w=s.G2.fromObject(r.vk_gamma_2),b=s.G2.fromObject(r.vk_delta_2),p=s.G1.fromObject(r.vk_alpha_1),y=s.G2.fromObject(r.vk_beta_2),v=await s.pairingEq(s.G1.neg(m),h,c,w,g,b,p,y);return v?(i&&i.info("OK!"),!0):(i&&i.error("Invalid proof"),!1)}let{unstringifyBigInts:x}=n.utils;function p256$2(e){let t=e.toString(16);for(;t.length<64;)t="0"+t;return`"0x${t}"`}var P=Object.freeze({__proto__:null,fullProve:groth16FullProve,prove:groth16Prove,verify:groth16Verify,exportSolidityCallData:async function(e,t){let a=x(e),i=x(t),n="";for(let e=0;e<i.length;e++)""!=n&&(n+=","),n+=p256$2(i[e]);return`[${p256$2(a.pi_a[0])}, ${p256$2(a.pi_a[1])}],[[${p256$2(a.pi_b[0][1])}, ${p256$2(a.pi_b[0][0])}],[${p256$2(a.pi_b[1][1])}, ${p256$2(a.pi_b[1][0])}]],[${p256$2(a.pi_c[0])}, ${p256$2(a.pi_c[1])}],[${n}]`}});function hashToG2(e,t){let a=new DataView(t.buffer,t.byteOffset,t.byteLength),i=[];for(let e=0;e<8;e++)i[e]=a.getUint32(4*e);let r=new n.ChaCha(i),o=e.G2.fromRng(r);return o}function getG2sp(e,t,a,i,n){let r=m.default(64),o=new Uint8Array([t]);r.update(o),r.update(a);let l=e.G1.toUncompressed(i);r.update(l);let s=e.G1.toUncompressed(n);r.update(s);let u=r.digest();return hashToG2(e,u)}function calculatePubKey(e,t,a,i,n){return e.g1_s=t.G1.toAffine(t.G1.fromRng(n)),e.g1_sx=t.G1.toAffine(t.G1.timesFr(e.g1_s,e.prvKey)),e.g2_sp=t.G2.toAffine(getG2sp(t,a,i,e.g1_s,e.g1_sx)),e.g2_spx=t.G2.toAffine(t.G2.timesFr(e.g2_sp,e.prvKey)),e}async function readPTauHeader(e,t){if(!t[1])throw Error(e.fileName+": File has no  header");if(t[1].length>1)throw Error(e.fileName+": File has more than one header");e.pos=t[1][0].p;let a=await e.readULE32(),i=await e.read(a),r=n.Scalar.fromRprLE(i),o=await getCurveFromQ(r);if(8*o.F1.n64!=a)throw Error(e.fileName+": Invalid size");let l=await e.readULE32(),s=await e.readULE32();if(e.pos-t[1][0].p!=t[1][0].size)throw Error("Invalid PTau header size");return{curve:o,power:l,ceremonyPower:s}}async function readPtauPubKey(e,t,a){let i=await e.read(12*t.F1.n8+6*t.F2.n8);return function(e,t,a,i){let n={tau:{},alpha:{},beta:{}};return n.tau.g1_s=readG1(),n.tau.g1_sx=readG1(),n.alpha.g1_s=readG1(),n.alpha.g1_sx=readG1(),n.beta.g1_s=readG1(),n.beta.g1_sx=readG1(),n.tau.g2_spx=readG2(),n.alpha.g2_spx=readG2(),n.beta.g2_spx=readG2(),n;function readG1(){let n;return n=i?a.G1.fromRprLEM(e,t):a.G1.fromRprUncompressed(e,t),t+=2*a.G1.F.n8,n}function readG2(){let n;return n=i?a.G2.fromRprLEM(e,t):a.G2.fromRprUncompressed(e,t),t+=2*a.G2.F.n8,n}}(i,0,t,a)}function toPtauPubKeyRpr(e,t,a,i,n){async function writeG1(i){n?a.G1.toRprLEM(e,t,i):a.G1.toRprUncompressed(e,t,i),t+=2*a.F1.n8}async function writeG2(i){n?a.G2.toRprLEM(e,t,i):a.G2.toRprUncompressed(e,t,i),t+=2*a.F2.n8}return writeG1(i.tau.g1_s),writeG1(i.tau.g1_sx),writeG1(i.alpha.g1_s),writeG1(i.alpha.g1_sx),writeG1(i.beta.g1_s),writeG1(i.beta.g1_sx),writeG2(i.tau.g2_spx),writeG2(i.alpha.g2_spx),writeG2(i.beta.g2_spx),e}async function writePtauPubKey(e,t,a,i){let n=new Uint8Array(12*t.F1.n8+6*t.F2.n8);toPtauPubKeyRpr(n,0,t,a,i),await e.write(n)}async function readContribution(e,t){let a={};a.tauG1=await readG1(),a.tauG2=await readG2(),a.alphaG1=await readG1(),a.betaG1=await readG1(),a.betaG2=await readG2(),a.key=await readPtauPubKey(e,t,!0),a.partialHash=await e.read(216),a.nextChallenge=await e.read(64),a.type=await e.readULE32();let i=new Uint8Array(12*t.G1.F.n8+6*t.G2.F.n8);toPtauPubKeyRpr(i,0,t,a.key,!1);let n=m.default(64);n.setPartialHash(a.partialHash),n.update(i),a.responseHash=n.digest();let r=await e.readULE32(),o=e.pos,l=0;for(;e.pos-o<r;){let e=await readDV(1);if(e[0]<=l)throw Error("Parameters in the contribution must be sorted");if(l=e[0],1==e[0]){let e=await readDV(1),t=await readDV(e[0]);a.name=new TextDecoder().decode(t)}else if(2==e[0]){let e=await readDV(1);a.numIterationsExp=e[0]}else if(3==e[0]){let e=await readDV(1);a.beaconHash=await readDV(e[0])}else throw Error("Parameter not recognized")}if(e.pos!=o+r)throw Error("Parametes do not match");return a;async function readG1(){let a=await e.read(2*t.G1.F.n8);return t.G1.fromRprLEM(a)}async function readG2(){let a=await e.read(2*t.G2.F.n8);return t.G2.fromRprLEM(a)}async function readDV(t){let a=await e.read(t);return new Uint8Array(a)}}async function writeContribution(e,t,a){let i=new Uint8Array(2*t.F1.n8),n=new Uint8Array(2*t.F2.n8);await writeG1(a.tauG1),await writeG2(a.tauG2),await writeG1(a.alphaG1),await writeG1(a.betaG1),await writeG2(a.betaG2),await writePtauPubKey(e,t,a.key,!0),await e.write(a.partialHash),await e.write(a.nextChallenge),await e.writeULE32(a.type||0);let r=[];if(a.name){r.push(1);let e=new TextEncoder("utf-8").encode(a.name.substring(0,64));r.push(e.byteLength);for(let t=0;t<e.byteLength;t++)r.push(e[t])}if(1==a.type){r.push(2),r.push(a.numIterationsExp),r.push(3),r.push(a.beaconHash.byteLength);for(let e=0;e<a.beaconHash.byteLength;e++)r.push(a.beaconHash[e])}if(r.length>0){let t=new Uint8Array(r);await e.writeULE32(t.byteLength),await e.write(t)}else await e.writeULE32(0);async function writeG1(a){t.G1.toRprLEM(i,0,a),await e.write(i)}async function writeG2(a){t.G2.toRprLEM(n,0,a),await e.write(n)}}async function keyFromBeacon(e,t,a,i){let n=await rngFromBeaconParams(a,i),r=function(e,t,a){let i={tau:{},alpha:{},beta:{}};return i.tau.prvKey=e.Fr.fromRng(a),i.alpha.prvKey=e.Fr.fromRng(a),i.beta.prvKey=e.Fr.fromRng(a),calculatePubKey(i.tau,e,0,t,a),calculatePubKey(i.alpha,e,1,t,a),calculatePubKey(i.beta,e,2,t,a),i}(e,t,n);return r}async function applyKeyToSection(e,t,a,i,n,r,o,l,s,u){let d=n[r],f=2*d.F.n8,m=t[i][0].size/f;await c.startReadUniqueSection(e,t,i),await c.startWriteSection(a,i);let h=o;for(let t=0;t<m;t+=65536){let i;u&&u.debug(`Applying key: ${s}: ${t}/${m}`);let r=Math.min(m-t,65536);i=await e.read(r*f),i=await d.batchApplyKey(i,h,l),await a.write(i),h=n.Fr.mul(h,n.Fr.exp(l,r))}await c.endWriteSection(a),await c.endReadSection(e)}async function applyKeyToChallengeSection(e,t,a,i,n,r,o,l,s,u,d){let f=i[n],c=2*f.F.n8,m=Math.floor(1048576/c),h=o;for(let n=0;n<r;n+=m){let o;d&&d.debug(`Applying key ${u}: ${n}/${r}`);let g=Math.min(r-n,m),w=await e.read(g*c),b=await f.batchUtoLEM(w),p=await f.batchApplyKey(b,h,l);o="COMPRESSED"==s?await f.batchLEMtoC(p):await f.batchLEMtoU(p),a&&a.update(o),await t.write(o),h=i.Fr.mul(h,i.Fr.exp(l,g))}}n.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),n.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");let{unstringifyBigInts:L}=n.utils,A={get:function(e,t){return isNaN(t)?e[t]:e.getElement(t)},set:function(e,t,a){return isNaN(t)?(e[t]=a,!0):e.setElement(t,a)}};let _BigArray=class _BigArray{constructor(e){this.length=e||0,this.arr=Array(262144);for(let t=0;t<e;t+=262144)this.arr[t/262144]=Array(Math.min(262144,e-t));return this}push(){for(let e=0;e<arguments.length;e++)this.setElement(this.length,arguments[e])}slice(e,t){let a=Array(t-e);for(let i=e;i<t;i++)a[i-e]=this.getElement(i);return a}getElement(e){e=parseInt(e);let t=Math.floor(e/262144),a=e%262144;return this.arr[t]?this.arr[t][a]:void 0}setElement(e,t){e=parseInt(e);let a=Math.floor(e/262144);this.arr[a]||(this.arr[a]=Array(262144));let i=e%262144;return this.arr[a][i]=t,e>=this.length&&(this.length=e+1),!0}getKeys(){let e=new BigArray;for(let t=0;t<this.arr.length;t++)if(this.arr[t])for(let a=0;a<this.arr[t].length;a++)void 0!==this.arr[t][a]&&e.push(262144*t+a);return e}};let BigArray=class BigArray{constructor(e){let t=new _BigArray(e),a=new Proxy(t,A);return a}};async function newZKey(e,t,a,r){let o,l,s;await m.default.ready();let d=m.default(64),{fd:f,sections:c}=await i.readBinFile(t,"ptau",1,4194304,16777216),{curve:h,power:g}=await readPTauHeader(f,c),{fd:w,sections:b}=await i.readBinFile(e,"r1cs",1,4194304,16777216),p=await u.readR1csHeader(w,b,!1),y=await i.createBinFile(a,"zkey",1,10,4194304,16777216),v=2*h.G1.F.n8,S=2*h.G2.F.n8;if(p.prime!=h.r)return r&&r.error("r1cs curve does not match powers of tau ceremony curve"),-1;let C=log2(p.nConstraints+p.nPubInputs+p.nOutputs+1-1)+1;if(C>g)return r&&r.error(`circuit too big for this power of tau ceremony. ${p.nConstraints}*2 > 2**${g}`),-1;if(!c[12])return r&&r.error("Powers of tau is not prepared."),-1;let F=p.nOutputs+p.nPubInputs,E=2**C;await i.startWriteSection(y,1),await y.writeULE32(1),await i.endWriteSection(y),await i.startWriteSection(y,2);let B=h.q,x=(Math.floor((n.Scalar.bitLength(B)-1)/64)+1)*8,P=h.r,L=(Math.floor((n.Scalar.bitLength(P)-1)/64)+1)*8,A=n.Scalar.mod(n.Scalar.shl(1,8*L),P),T=h.Fr.e(n.Scalar.mod(n.Scalar.mul(A,A),P));await y.writeULE32(x),await i.writeBigInt(y,B,x),await y.writeULE32(L),await i.writeBigInt(y,P,L),await y.writeULE32(p.nVars),await y.writeULE32(F),await y.writeULE32(E),o=await f.read(v,c[4][0].p),await y.write(o),o=await h.G1.batchLEMtoU(o),d.update(o),l=await f.read(v,c[5][0].p),await y.write(l),l=await h.G1.batchLEMtoU(l),d.update(l),s=await f.read(S,c[6][0].p),await y.write(s),s=await h.G2.batchLEMtoU(s),d.update(s);let _=new Uint8Array(v);h.G1.toRprLEM(_,0,h.G1.g);let G=new Uint8Array(S);h.G2.toRprLEM(G,0,h.G2.g);let R=new Uint8Array(v);h.G1.toRprUncompressed(R,0,h.G1.g);let z=new Uint8Array(S);h.G2.toRprUncompressed(z,0,h.G2.g),await y.write(G),await y.write(_),await y.write(G),d.update(z),d.update(R),d.update(z),await i.endWriteSection(y),r&&r.info("Reading r1cs");let U=await i.readSection(w,b,2),k=new BigArray(p.nVars),I=new BigArray(p.nVars),O=new BigArray(p.nVars),$=new BigArray(p.nVars-F-1),V=Array(F+1);r&&r.info("Reading tauG1");let q=await i.readSection(f,c,12,(E-1)*v,E*v);r&&r.info("Reading tauG2");let Q=await i.readSection(f,c,13,(E-1)*S,E*S);r&&r.info("Reading alphatauG1");let Z=await i.readSection(f,c,14,(E-1)*v,E*v);r&&r.info("Reading betatauG1");let M=await i.readSection(f,c,15,(E-1)*v,E*v);await processConstraints(),await composeAndWritePoints(3,"G1",V,"IC"),await writeHs(),await hashHPoints(),await composeAndWritePoints(8,"G1",$,"C"),await composeAndWritePoints(5,"G1",k,"A"),await composeAndWritePoints(6,"G1",I,"B1"),await composeAndWritePoints(7,"G2",O,"B2");let W=d.digest();return await i.startWriteSection(y,10),await y.write(W),await y.writeULE32(0),await i.endWriteSection(y),r&&r.info(formatHash(W,"Circuit hash: ")),await y.close(),await w.close(),await f.close(),W;async function writeHs(){await i.startWriteSection(y,9);let e=new n.BigBuffer(E*v);if(C<h.Fr.s){let t=await i.readSection(f,c,12,(2*E-1)*v,2*E*v);for(let a=0;a<E;a++){r&&a%1e4==0&&r.debug(`spliting buffer: ${a}/${E}`);let i=t.slice((2*a+1)*v,(2*a+1)*v+v);e.set(i,a*v)}}else if(C==h.Fr.s){let t=c[12][0].p+(2**(C+1)-1)*v;await f.readToBuffer(e,0,E*v,t+E*v)}else throw r&&r.error("Circuit too big"),Error("Circuit too big for this curve");await y.write(e),await i.endWriteSection(y)}async function processConstraints(){let e=new Uint8Array(12+h.Fr.n8),t=new DataView(e.buffer),a=new Uint8Array(h.Fr.n8);h.Fr.toRprLE(a,0,h.Fr.e(1));let o=0;function r1cs_readULE32(){let e=U.slice(o,o+4);o+=4;let t=new DataView(e.buffer);return t.getUint32(0,!0)}let l=new BigArray;for(let e=0;e<p.nConstraints;e++){r&&e%1e4==0&&r.debug(`processing constraints: ${e}/${p.nConstraints}`);let t=r1cs_readULE32();for(let a=0;a<t;a++){let t=r1cs_readULE32(),a=o;o+=h.Fr.n8;let i=v*e,n=v*e;void 0===k[t]&&(k[t]=[]),k[t].push([0,i,a]),t<=F?(void 0===V[t]&&(V[t]=[]),V[t].push([3,n,a])):(void 0===$[t-F-1]&&($[t-F-1]=[]),$[t-F-1].push([3,n,a])),l.push([0,e,t,a])}let a=r1cs_readULE32();for(let t=0;t<a;t++){let t=r1cs_readULE32(),a=o;o+=h.Fr.n8;let i=v*e,n=S*e,r=v*e;void 0===I[t]&&(I[t]=[]),I[t].push([0,i,a]),void 0===O[t]&&(O[t]=[]),O[t].push([1,n,a]),t<=F?(void 0===V[t]&&(V[t]=[]),V[t].push([2,r,a])):(void 0===$[t-F-1]&&($[t-F-1]=[]),$[t-F-1].push([2,r,a])),l.push([1,e,t,a])}let i=r1cs_readULE32();for(let t=0;t<i;t++){let t=r1cs_readULE32(),a=o;o+=h.Fr.n8;let i=v*e;t<=F?(void 0===V[t]&&(V[t]=[]),V[t].push([0,i,a])):(void 0===$[t-F-1]&&($[t-F-1]=[]),$[t-F-1].push([0,i,a]))}}for(let e=0;e<=F;e++){let t=v*(p.nConstraints+e),a=v*(p.nConstraints+e);void 0===k[e]&&(k[e]=[]),k[e].push([0,t,-1]),void 0===V[e]&&(V[e]=[]),V[e].push([3,a,-1]),l.push([0,p.nConstraints+e,e,-1])}await i.startWriteSection(y,4);let s=new n.BigBuffer(l.length*(12+h.Fr.n8)+4),u=new Uint8Array(4),d=new DataView(u.buffer);d.setUint32(0,l.length,!0),s.set(u);let f=4;for(let i=0;i<l.length;i++)r&&i%1e5==0&&r.debug(`writing coeffs: ${i}/${l.length}`),function(i){let n;t.setUint32(0,i[0],!0),t.setUint32(4,i[1],!0),t.setUint32(8,i[2],!0),n=i[3]>=0?h.Fr.fromRprLE(U.slice(i[3],i[3]+h.Fr.n8),0):h.Fr.fromRprLE(a,0);let r=h.Fr.mul(n,T);h.Fr.toRprLE(e,12,r),s.set(e,f),f+=e.length}(l[i]);await y.write(s),await i.endWriteSection(y)}async function composeAndWritePoints(e,t,a,n){let o=h[t];hashU32(a.length),await i.startWriteSection(y,e);let l=[],s=0;for(;s<a.length;){let e=0;for(;s<a.length&&e<h.tm.concurrency;){r&&r.debug(`Writing points start ${n}: ${s}/${a.length}`);let i=1,o=a[s]?a[s].length:0;for(;s+i<a.length&&o+(a[s+i]?a[s+i].length:0)<32768&&i<32768;)o+=a[s+i]?a[s+i].length:0,i++;let u=a.slice(s,s+i),d=s;l.push(composeAndWritePointsThread(t,u,r,n).then(e=>(r&&r.debug(`Writing points end ${n}: ${d}/${a.length}`),e))),s+=i,e++}let i=await Promise.all(l);for(let e=0;e<i.length;e++){await y.write(i[e][0]);let t=await o.batchLEMtoU(i[e][0]);d.update(t)}l=[]}await i.endWriteSection(y)}async function composeAndWritePointsThread(e,t,a,i){let r,o,l,s,u,d;let f=h[e],c=2*f.F.n8,m=3*f.F.n8,g=2*f.F.n8;if("G1"==e)r="g1m_timesScalarAffine",o="g1m_multiexpAffine",l="g1m_batchToAffine",s="g1m_zero";else if("G2"==e)r="g2m_timesScalarAffine",o="g2m_multiexpAffine",l="g2m_batchToAffine",s="g2m_zero";else throw Error("Invalid group");let w=0;for(let e=0;e<t.length;e++)w+=t[e]?t[e].length:0;w>32768?(u=new n.BigBuffer(w*c),d=new n.BigBuffer(w*h.Fr.n8)):(u=new Uint8Array(w*c),d=new Uint8Array(w*h.Fr.n8));let b=0,p=0,y=[q,Q,Z,M],v=new Uint8Array(h.Fr.n8);h.Fr.toRprLE(v,0,h.Fr.e(1));let S=0;for(let e=0;e<t.length;e++)if(t[e])for(let n=0;n<t[e].length;n++)a&&n&&n%1e4==0&&a.debug(`Configuring big array ${i}: ${n}/${t[e].length}`),u.set(y[t[e][n][0]].slice(t[e][n][1],t[e][n][1]+c),S*c),t[e][n][2]>=0?d.set(U.slice(t[e][n][2],t[e][n][2]+h.Fr.n8),S*h.Fr.n8):d.set(v,S*h.Fr.n8),S++;if(t.length>1){let e=[];e.push({cmd:"ALLOCSET",var:0,buff:u}),e.push({cmd:"ALLOCSET",var:1,buff:d}),e.push({cmd:"ALLOC",var:2,len:t.length*m}),b=0,p=0;let a=0;for(let i=0;i<t.length;i++){if(!t[i]){e.push({cmd:"CALL",fnName:s,params:[{var:2,offset:a}]}),a+=m;continue}1==t[i].length?e.push({cmd:"CALL",fnName:r,params:[{var:0,offset:b},{var:1,offset:p},{val:h.Fr.n8},{var:2,offset:a}]}):e.push({cmd:"CALL",fnName:o,params:[{var:0,offset:b},{var:1,offset:p},{val:h.Fr.n8},{val:t[i].length},{var:2,offset:a}]}),b+=c*t[i].length,p+=h.Fr.n8*t[i].length,a+=m}e.push({cmd:"CALL",fnName:l,params:[{var:2},{val:t.length},{var:2}]}),e.push({cmd:"GET",out:0,var:2,len:t.length*g});let i=await h.tm.queueAction(e);return i}{let e=await f.multiExpAffine(u,d,a,i);return[f.toAffine(e)]}}async function hashHPoints(){hashU32(E-1);for(let e=0;e<E-1;e+=16384){r&&r.debug(`HashingHPoints: ${e}/${E}`);let t=Math.min(E-1,16384);await hashHPointsChunk(e,t)}}async function hashHPointsChunk(e,t){let a=await f.read(t*v,c[2][0].p+(e+E)*v),i=await f.read(t*v,c[2][0].p+e*v),n=h.tm.concurrency,r=Math.floor(t/n),o=[];for(let e=0;e<n;e++){let l;if(0==(l=e<n-1?r:t-e*r))continue;let s=a.slice(e*r*v,(e*r+l)*v),u=i.slice(e*r*v,(e*r+l)*v);o.push(hashHPointsThread(s,u))}let l=await Promise.all(o);for(let e=0;e<l.length;e++)d.update(l[e][0])}async function hashHPointsThread(e,t){let a=e.byteLength/v,i=3*h.G1.F.n8,n=[];n.push({cmd:"ALLOCSET",var:0,buff:e}),n.push({cmd:"ALLOCSET",var:1,buff:t}),n.push({cmd:"ALLOC",var:2,len:a*i});for(let e=0;e<a;e++)n.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:e*v},{var:1,offset:e*v},{var:2,offset:e*i}]});n.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:a},{var:2}]}),n.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:a},{var:2}]}),n.push({cmd:"GET",out:0,var:2,len:a*v});let r=await h.tm.queueAction(n);return r}function hashU32(e){let t=new Uint8Array(4),a=new DataView(t.buffer,t.byteOffset,t.byteLength);a.setUint32(0,e,!1),d.update(t)}}async function phase2verifyFromInit(e,t,a,i){await m.default.ready();let{fd:r,sections:o}=await c.readBinFile(a,"zkey",2),l=await readHeader$1(r,o,!1);if("groth16"!=l.protocol)throw Error("zkey file is not groth16");let s=await getCurveFromQ(l.q),u=2*s.G1.F.n8,d=await readMPCParams(r,s,o),f=m.default(64);f.update(d.csHash);let h=s.G1.g;for(let e=0;e<d.contributions.length;e++){let t=d.contributions[e],a=function(e){let t=e.getPartialHash(),a=m.default(64);return a.setPartialHash(t),a}(f);if(hashG1(a,s,t.delta.g1_s),hashG1(a,s,t.delta.g1_sx),!hashIsEqual(a.digest(),t.transcript))return console.log(`INVALID(${e}): Inconsistent transcript `),!1;let i=hashToG2(s,t.transcript);if(!0!==await sameRatio$2(s,t.delta.g1_s,t.delta.g1_sx,i,t.delta.g2_spx))return console.log(`INVALID(${e}): public key G1 and G2 do not have the same ration `),!1;if(!0!==await sameRatio$2(s,h,t.deltaAfter,i,t.delta.g2_spx))return console.log(`INVALID(${e}): deltaAfter does not fillow the public key `),!1;if(1==t.type){let a=await rngFromBeaconParams(t.beaconHash,t.numIterationsExp),i=s.Fr.fromRng(a),n=s.G1.toAffine(s.G1.fromRng(a)),r=s.G1.toAffine(s.G1.timesFr(n,i));if(!0!==s.G1.eq(n,t.delta.g1_s))return console.log(`INVALID(${e}): Key of the beacon does not match. g1_s `),!1;if(!0!==s.G1.eq(r,t.delta.g1_sx))return console.log(`INVALID(${e}): Key of the beacon does not match. g1_sx `),!1}hashPubKey(f,s,t);let n=m.default(64);hashPubKey(n,s,t),t.contributionHash=n.digest(),h=t.deltaAfter}let{fd:g,sections:w}=await c.readBinFile(e,"zkey",2),b=await readHeader$1(g,w,!1);if("groth16"!=b.protocol)throw Error("zkeyinit file is not groth16");if(!n.Scalar.eq(b.q,l.q)||!n.Scalar.eq(b.r,l.r)||b.n8q!=l.n8q||b.n8r!=l.n8r)return i&&i.error("INVALID:  Different curves"),!1;if(b.nVars!=l.nVars||b.nPublic!=l.nPublic||b.domainSize!=l.domainSize)return i&&i.error("INVALID:  Different circuit parameters"),!1;if(!s.G1.eq(l.vk_alpha_1,b.vk_alpha_1))return i&&i.error("INVALID:  Invalid alpha1"),!1;if(!s.G1.eq(l.vk_beta_1,b.vk_beta_1))return i&&i.error("INVALID:  Invalid beta1"),!1;if(!s.G2.eq(l.vk_beta_2,b.vk_beta_2))return i&&i.error("INVALID:  Invalid beta2"),!1;if(!s.G2.eq(l.vk_gamma_2,b.vk_gamma_2))return i&&i.error("INVALID:  Invalid gamma2"),!1;if(!s.G1.eq(l.vk_delta_1,h))return i&&i.error("INVALID:  Invalid delta1"),!1;if(!0!==await sameRatio$2(s,s.G1.g,h,s.G2.g,l.vk_delta_2))return i&&i.error("INVALID:  Invalid delta2"),!1;let p=await readMPCParams(g,s,w);if(!hashIsEqual(d.csHash,p.csHash))return i&&i.error("INVALID:  Circuit does not match"),!1;if(o[8][0].size!=u*(l.nVars-l.nPublic-1))return i&&i.error("INVALID:  Invalid L section size"),!1;if(o[9][0].size!=u*l.domainSize)return i&&i.error("INVALID:  Invalid H section size"),!1;if(!await c.sectionIsEqual(r,o,g,w,3))return i&&i.error("INVALID:  IC section is not identical"),!1;if(!await c.sectionIsEqual(r,o,g,w,4))return i&&i.error("Coeffs section is not identical"),!1;if(!await c.sectionIsEqual(r,o,g,w,5))return i&&i.error("A section is not identical"),!1;if(!await c.sectionIsEqual(r,o,g,w,6))return i&&i.error("B1 section is not identical"),!1;if(!await c.sectionIsEqual(r,o,g,w,7))return i&&i.error("B2 section is not identical"),!1;if(!0!==await sectionHasSameRatio("G1",g,w,r,o,8,l.vk_delta_2,b.vk_delta_2,"L section"))return i&&i.error("L section does not match"),!1;if(!0!==await sameRatioH())return i&&i.error("H section does not match"),!1;i&&i.info(formatHash(d.csHash,"Circuit Hash: ")),await r.close(),await g.close();for(let e=d.contributions.length-1;e>=0;e--){var y;let t=d.contributions[e];i&&i.info("-------------------------"),i&&i.info(formatHash(t.contributionHash,`contribution #${e+1} ${t.name?t.name:""}:`)),1==t.type&&(i&&i.info(`Beacon generator: ${(y=t.beaconHash,Array.prototype.map.call(y,function(e){return("0"+(255&e).toString(16)).slice(-2)}).join(""))}`),i&&i.info(`Beacon iterations Exp: ${t.numIterationsExp}`))}return i&&i.info("-------------------------"),i&&i.info("ZKey Ok!"),!0;async function sectionHasSameRatio(e,t,a,n,r,o,l,u,d){let f=s[e],m=2*f.F.n8;await c.startReadUniqueSection(t,a,o),await c.startReadUniqueSection(n,r,o);let h=f.zero,g=f.zero,w=a[o][0].size/m;for(let e=0;e<w;e+=1048576){i&&i.debug(`Same ratio check ${d}:  ${e}/${w}`);let a=Math.min(w-e,1048576),r=await t.read(a*m),o=await n.read(a*m),l=getRandomBytes(4*a),s=await f.multiExpAffine(r,l),u=await f.multiExpAffine(o,l);h=f.add(h,s),g=f.add(g,u)}return await c.endReadSection(t),await c.endReadSection(n),0==w||!0===await sameRatio$2(s,h,g,l,u)}async function sameRatioH(){let e;let a=s.G1,u=s.Fr,d=2*a.F.n8,{fd:f,sections:m}=await c.readBinFile(t,"ptau",1),h=new n.BigBuffer(l.domainSize*l.n8r),g=Array(8);for(let e=0;e<8;e++)g[e]=readUInt32BE(getRandomBytes(4),0);let w=new n.ChaCha(g);for(let e=0;e<l.domainSize-1;e++){let t=u.fromRng(w);u.toRprLE(h,e*l.n8r,t)}u.toRprLE(h,(l.domainSize-1)*l.n8r,u.zero);let p=a.zero;for(let e=0;e<l.domainSize;e+=1048576){i&&i.debug(`H Verificaition(tau):  ${e}/${l.domainSize}`);let t=Math.min(l.domainSize-e,1048576),n=await f.read(d*t,m[2][0].p+l.domainSize*d+e*d),r=await f.read(d*t,m[2][0].p+e*d),o=await batchSubstract(n,r),s=h.slice(e*l.n8r,(e+t)*l.n8r),u=await a.multiExpAffine(o,s);p=a.add(p,u)}if(h=await u.batchToMontgomery(h),l.power<u.s)e=u.neg(u.e(2));else{let t=2**u.s,a=u.exp(u.shift,t);e=u.sub(a,u.one)}let y=l.power<u.s?u.w[l.power+1]:u.shift;h=await u.batchApplyKey(h,e,y),h=await u.fft(h),h=await u.batchFromMontgomery(h),await c.startReadUniqueSection(r,o,9);let v=a.zero;for(let e=0;e<l.domainSize;e+=1048576){i&&i.debug(`H Verificaition(lagrange):  ${e}/${l.domainSize}`);let t=Math.min(l.domainSize-e,1048576),n=await r.read(d*t),o=h.slice(e*l.n8r,(e+t)*l.n8r),s=await a.multiExpAffine(n,o);v=a.add(v,s)}return await c.endReadSection(r),!0===await sameRatio$2(s,p,v,l.vk_delta_2,b.vk_delta_2)}async function batchSubstract(e,t){let a=2*s.G1.F.n8,i=e.byteLength/a,n=s.tm.concurrency,r=Math.floor(i/n),o=[];for(let a=0;a<n;a++){let l;if(0==(l=a<n-1?r:i-a*r))continue;let s=e.slice(a*r*u,(a*r+l)*u),d=t.slice(a*r*u,(a*r+l)*u);o.push(batchSubstractThread(s,d))}let l=await Promise.all(o),d=new Uint8Array(i*a),f=0;for(let e=0;e<l.length;e++)d.set(l[e][0],f),f+=l[e][0].byteLength;return d}async function batchSubstractThread(e,t){let a=2*s.G1.F.n8,i=3*s.G1.F.n8,n=e.byteLength/a,r=[];r.push({cmd:"ALLOCSET",var:0,buff:e}),r.push({cmd:"ALLOCSET",var:1,buff:t}),r.push({cmd:"ALLOC",var:2,len:n*i});for(let e=0;e<n;e++)r.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:e*a},{var:1,offset:e*a},{var:2,offset:e*i}]});r.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:n},{var:2}]}),r.push({cmd:"GET",out:0,var:2,len:n*a});let o=await s.tm.queueAction(r);return o}}let{stringifyBigInts:T}=n.utils;async function zkeyExportVerificationKey(e,t){let a;t&&t.info("EXPORT VERIFICATION KEY STARTED");let{fd:i,sections:n}=await c.readBinFile(e,"zkey",2),r=await readHeader$1(i,n);if(t&&t.info("> Detected protocol: "+r.protocol),"groth16"===r.protocol)a=await groth16Vk(r,i,n);else if("plonk"===r.protocol)a=await plonkVk(r);else if(r.protocolId&&10===r.protocolId)a=await exportFFlonkVk(r);else throw Error("zkey file protocol unrecognized");return await i.close(),t&&t.info("EXPORT VERIFICATION KEY FINISHED"),a}async function groth16Vk(e,t,a){let i=await getCurveFromQ(e.q),n=2*i.G1.F.n8,r=await i.pairing(e.vk_alpha_1,e.vk_beta_2),o={protocol:e.protocol,curve:i.name,nPublic:e.nPublic,vk_alpha_1:i.G1.toObject(e.vk_alpha_1),vk_beta_2:i.G2.toObject(e.vk_beta_2),vk_gamma_2:i.G2.toObject(e.vk_gamma_2),vk_delta_2:i.G2.toObject(e.vk_delta_2),vk_alphabeta_12:i.Gt.toObject(r)};await c.startReadUniqueSection(t,a,3),o.IC=[];for(let a=0;a<=e.nPublic;a++){let e=await t.read(n),a=i.G1.toObject(e);o.IC.push(a)}return await c.endReadSection(t),o=T(o)}async function plonkVk(e){let t=await getCurveFromQ(e.q);return T({protocol:e.protocol,curve:t.name,nPublic:e.nPublic,power:e.power,k1:t.Fr.toObject(e.k1),k2:t.Fr.toObject(e.k2),Qm:t.G1.toObject(e.Qm),Ql:t.G1.toObject(e.Ql),Qr:t.G1.toObject(e.Qr),Qo:t.G1.toObject(e.Qo),Qc:t.G1.toObject(e.Qc),S1:t.G1.toObject(e.S1),S2:t.G1.toObject(e.S2),S3:t.G1.toObject(e.S3),X_2:t.G2.toObject(e.X_2),w:t.Fr.toObject(t.Fr.w[e.power])})}async function exportFFlonkVk(e,t){let a=await getCurveFromQ(e.q);return T({protocol:e.protocol,curve:a.name,nPublic:e.nPublic,power:e.power,k1:a.Fr.toObject(e.k1),k2:a.Fr.toObject(e.k2),w:a.Fr.toObject(a.Fr.w[e.power]),w3:a.Fr.toObject(e.w3),w4:a.Fr.toObject(e.w4),w8:a.Fr.toObject(e.w8),wr:a.Fr.toObject(e.wr),X_2:a.G2.toObject(e.X_2),C0:a.G1.toObject(e.C0)})}let{unstringifyBigInts:_,stringifyBigInts:G}=n.utils;async function fflonkExportSolidityVerifier(e,t,a){a&&a.info("FFLONK EXPORT SOLIDITY VERIFIER STARTED");let i=await getCurveFromName(e.curve),n=fromVkey(e.w3);e.w3_2=toVkey(i.Fr.square(n));let r=fromVkey(e.w4);e.w4_2=toVkey(i.Fr.square(r)),e.w4_3=toVkey(i.Fr.mul(i.Fr.square(r),r));let o=fromVkey(e.w8),l=i.Fr.one;for(let t=1;t<8;t++)l=i.Fr.mul(l,o),e["w8_"+t]=toVkey(l);let s=t[e.protocol];return a&&a.info("FFLONK EXPORT SOLIDITY VERIFIER FINISHED"),w.default.render(s,e);function fromVkey(e){let t=_(e);return i.Fr.fromObject(t)}function toVkey(e){let t=i.Fr.toObject(e);return G(t)}}let Proof=class Proof{constructor(e,t){this.curve=e,this.logger=t,this.resetProof()}resetProof(){this.polynomials={},this.evaluations={}}addPolynomial(e,t){e in this.polynomials&&this.logger.warn(`proof: polynomial.${e} already exist in proof`),this.polynomials[e]=t}getPolynomial(e){return e in this.polynomials||this.logger.warn(`proof: polynomial ${e} does not exist in proof`),this.polynomials[e]}addEvaluation(e,t){e in this.evaluations&&this.logger.warn(`proof: evaluations.${e} already exist in proof`),this.evaluations[e]=t}getEvaluation(e){return e in this.evaluations||this.logger.warn(`proof: evaluation ${e} does not exist in proof`),this.evaluations[e]}toObjectProof(e=!0){let t=e?{polynomials:{},evaluations:{}}:{};return Object.keys(this.polynomials).forEach(a=>{let i=this.curve.G1.toObject(this.polynomials[a]);e?t.polynomials[a]=i:t[a]=i}),Object.keys(this.evaluations).forEach(a=>{let i=this.curve.Fr.toObject(this.evaluations[a]);e?t.evaluations[a]=i:t[a]=i}),t}fromObjectProof(e){this.resetProof(),Object.keys(e.polynomials).forEach(t=>{this.polynomials[t]=this.curve.G1.fromObject(e.polynomials[t])}),Object.keys(e.evaluations).forEach(t=>{this.evaluations[t]=this.curve.Fr.fromObject(e.evaluations[t])})}};let{keccak256:R}=b.default;let Keccak256Transcript=class Keccak256Transcript{constructor(e){this.G1=e.G1,this.Fr=e.Fr,this.reset()}reset(){this.data=[]}addPolCommitment(e){this.data.push({type:0,data:e})}addScalar(e){this.data.push({type:1,data:e})}getChallenge(){if(0===this.data.length)throw Error("Keccak256Transcript: No data to generate a transcript");let e=0,t=0;this.data.forEach(a=>0===a.type?e++:t++);let a=new Uint8Array(t*this.Fr.n8+e*this.G1.F.n8*2),i=0;for(let e=0;e<this.data.length;e++)0===this.data[e].type?(this.G1.toRprUncompressed(a,i,this.data[e].data),i+=2*this.G1.F.n8):(this.Fr.toRprBE(a,i,this.data[e].data),i+=this.Fr.n8);let r=n.Scalar.fromRprBE(new Uint8Array(R.arrayBuffer(a)));return this.Fr.e(r)}};let MulZ=class MulZ{static getZ1(e){return[e.zero,e.add(e.e(-1),e.w[2]),e.e(-2),e.sub(e.e(-1),e.w[2])]}static getZ2(e){return[e.zero,e.add(e.zero,e.mul(e.e(-2),e.w[2])),e.e(4),e.sub(e.zero,e.mul(e.e(-2),e.w[2]))]}static getZ3(e){return[e.zero,e.add(e.e(2),e.mul(e.e(2),e.w[2])),e.e(-8),e.sub(e.e(2),e.mul(e.e(2),e.w[2]))]}static mul2(e,t,a,i,n,r){let o;let l=this.getZ1(r),s=r.mul(e,t),u=r.mul(e,i),d=r.mul(a,t),f=r.mul(a,i);return o=r.add(u,d),n&&(o=r.add(o,r.mul(l[n],f))),[s,o]}static mul3(e,t,a,i,n,r,o,l){let s,u;let d=this.getZ1(l),f=this.getZ2(l),c=l.mul(e,t),m=l.mul(e,n),h=l.mul(i,t),g=l.mul(i,n);s=l.mul(c,a);let w=l.mul(h,a);w=l.add(w,l.mul(m,a)),w=l.add(w,l.mul(c,r));let b=l.mul(g,a);if(b=l.add(b,l.mul(m,r)),b=l.add(b,l.mul(h,r)),u=w,o){let e=l.mul(g,r);u=l.add(u,l.mul(d[o],b)),u=l.add(u,l.mul(f[o],e))}return[s,u]}static mul4(e,t,a,i,n,r,o,l,s,u){let d,f;let c=this.getZ1(u),m=this.getZ2(u),h=this.getZ3(u),g=u.mul(e,t),w=u.mul(e,r),b=u.mul(n,t),p=u.mul(n,r),y=u.mul(a,i),v=u.mul(a,l),S=u.mul(o,i),C=u.mul(o,l);d=u.mul(g,y);let F=u.mul(b,y);F=u.add(F,u.mul(w,y)),F=u.add(F,u.mul(g,S)),F=u.add(F,u.mul(g,v));let E=u.mul(p,y);E=u.add(E,u.mul(b,S)),E=u.add(E,u.mul(b,v)),E=u.add(E,u.mul(w,S)),E=u.add(E,u.mul(w,v)),E=u.add(E,u.mul(g,C));let B=u.mul(w,C);B=u.add(B,u.mul(b,C)),B=u.add(B,u.mul(p,v)),B=u.add(B,u.mul(p,S));let x=u.mul(p,C);return f=F,s&&(f=u.add(f,u.mul(c[s],E)),f=u.add(f,u.mul(m[s],B)),f=u.add(f,u.mul(h[s],x))),[d,f]}};let Polynomial=class Polynomial{constructor(e,t,a){this.coef=e,this.curve=t,this.Fr=t.Fr,this.G1=t.G1,this.logger=a}static async fromEvaluations(e,t,a){let i=await t.Fr.ifft(e);return new Polynomial(i,t,a)}static fromCoefficientsArray(e,t,a){let i=t.Fr,r=e.length>32768?new n.BigBuffer(e.length*i.n8):new Uint8Array(e.length*i.n8);for(let t=0;t<e.length;t++)r.set(e[t],t*i.n8);return new Polynomial(r,t,a)}static fromPolynomial(e,t,a){let i=e.length(),r=t.Fr,o=i>32768?new n.BigBuffer(i*r.n8):new Uint8Array(i*r.n8);return o.set(e.coef.slice(),0),new Polynomial(o,t,a)}isEqual(e){let t=this.degree();if(t!==e.degree())return!1;for(let a=0;a<t+1;a++)if(!this.Fr.eq(this.getCoef(a),e.getCoef(a)))return!1;return!0}blindCoefficients(e){e=e||[];let t=this.length()+e.length>32768?new n.BigBuffer((this.length()+e.length)*this.Fr.n8):new Uint8Array((this.length()+e.length)*this.Fr.n8);t.set(this.coef,0);for(let a=0;a<e.length;a++)t.set(this.Fr.add(t.slice((this.length()+a)*this.Fr.n8,(this.length()+a+1)*this.Fr.n8),e[a]),(this.length()+a)*this.Fr.n8),t.set(this.Fr.sub(t.slice(a*this.Fr.n8,(a+1)*this.Fr.n8),e[a]),a*this.Fr.n8);this.coef=t}getCoef(e){let t=e*this.Fr.n8;return t+this.Fr.n8>this.coef.byteLength?this.Fr.zero:this.coef.slice(t,t+this.Fr.n8)}setCoef(e,t){if(e>this.length()-1)throw Error("Coef index is not available");this.coef.set(t,e*this.Fr.n8)}static async to4T(e,t,a,i){a=a||[];let r=await i.ifft(e),o=4*t>32768?new n.BigBuffer(4*t*i.n8):new Uint8Array(4*t*i.n8);o.set(r,0);let l=await i.fft(o);if(0===a.length)return[r,l];let s=t+a.length>32768?new n.BigBuffer((t+a.length)*i.n8):new Uint8Array((t+a.length)*i.n8);s.set(r,0);for(let e=0;e<a.length;e++)s.set(i.add(s.slice((t+e)*i.n8,(t+e+1)*i.n8),a[e]),(t+e)*i.n8),s.set(i.sub(s.slice(e*i.n8,(e+1)*i.n8),a[e]),e*i.n8);return[s,l]}length(){let e=this.coef.byteLength/this.Fr.n8;if(e!==Math.floor(this.coef.byteLength/this.Fr.n8))throw Error("Polynomial coefficients buffer has incorrect size");return 0===e&&this.logger&&this.logger.warn("Polynomial has length zero"),e}degree(){for(let e=this.length()-1;e>0;e--){let t=e*this.Fr.n8;if(!this.Fr.eq(this.Fr.zero,this.coef.slice(t,t+this.Fr.n8)))return e}return 0}evaluate(e){let t=this.Fr.zero;for(let a=this.degree()+1;a>0;a--){let i=a*this.Fr.n8,n=this.coef.slice(i-this.Fr.n8,i);t=this.Fr.add(n,this.Fr.mul(t,e))}return t}fastEvaluate(e){let t=this.Fr,a=this.degree()+1,i=parseInt(a/3),n=a-3*i,r=[],o=[];o[0]=t.one;for(let a=0;a<3;a++){r[a]=t.zero;let l=2===a?i+n:i;for(let n=l;n>0;n--)r[a]=t.add(this.getCoef(a*i+n-1),t.mul(r[a],e)),0===a&&(o[0]=t.mul(o[0],e))}for(let e=1;e<3;e++)r[0]=t.add(r[0],t.mul(o[e-1],r[e])),o[e]=t.mul(o[e-1],o[0]);return r[0]}add(e,t){let a=!1;e.length()>this.length()&&(a=!0);let i=this.length(),n=e.length();for(let r=0;r<Math.max(i,n);r++){let o=r*this.Fr.n8,l=r<i?this.coef.slice(o,o+this.Fr.n8):this.Fr.zero,s=r<n?e.coef.slice(o,o+this.Fr.n8):this.Fr.zero;void 0!==t&&(s=this.Fr.mul(s,t)),a?e.coef.set(this.Fr.add(l,s),o):this.coef.set(this.Fr.add(l,s),o)}a&&(delete this.coef,this.coef=e.coef)}sub(e,t){let a=!1;e.length()>this.length()&&(a=!0);let i=this.length(),n=e.length();for(let r=0;r<Math.max(i,n);r++){let o=r*this.Fr.n8,l=r<i?this.coef.slice(o,o+this.Fr.n8):this.Fr.zero,s=r<n?e.coef.slice(o,o+this.Fr.n8):this.Fr.zero;void 0!==t&&(s=this.Fr.mul(s,t)),a?e.coef.set(this.Fr.sub(l,s),o):this.coef.set(this.Fr.sub(l,s),o)}a&&(delete this.coef,this.coef=e.coef)}mulScalar(e){for(let t=0;t<this.length();t++){let a=t*this.Fr.n8;this.coef.set(this.Fr.mul(this.coef.slice(a,a+this.Fr.n8),e),a)}}addScalar(e){let t=0===this.length()?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.add(t,e),0)}subScalar(e){let t=0===this.length()?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.sub(t,e),0)}byXSubValue(e){let t=this.Fr,a=!t.eq(t.zero,this.getCoef(this.length()-1)),i=a?this.length()+1:this.length(),r=i>32768?new n.BigBuffer(i*t.n8):new Uint8Array(i*t.n8),o=new Polynomial(r,this.curve,this.logger);o.coef.set(this.coef.slice(0,(i-1)*t.n8),32),this.mulScalar(t.neg(e)),o.add(this),this.coef=o.coef}byXNSubValue(e,t){let a=this.Fr,i=!(this.length()-e-1>=this.degree()),r=i?this.length()+e:this.length(),o=r>32768?new n.BigBuffer(r*a.n8):new Uint8Array(r*a.n8),l=new Polynomial(o,this.curve,this.logger);l.coef.set(this.coef.slice(0,(this.degree()+1)*32),32*e),this.mulScalar(t),l.add(this),this.coef=l.coef}divBy(e){let t=this.Fr,a=this.degree(),i=e.degree(),r=new Polynomial(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new n.BigBuffer(this.length()*t.n8):new Uint8Array(this.length()*t.n8);for(let n=a-i;n>=0;n--){this.setCoef(n,t.div(r.getCoef(n+i),e.getCoef(i)));for(let a=0;a<=i;a++)r.setCoef(n+a,t.sub(r.getCoef(n+a),t.mul(this.getCoef(n),e.getCoef(a))))}return r}divByMonic(e,t){let a=this.Fr,i=this.degree(),r=this.length()>32768?new n.BigBuffer(this.length()*a.n8):new Uint8Array(this.length()*a.n8),o=new Polynomial(r,this.curve,this.logger),l=[];for(let t=0;t<e;t++)o.setCoef(i-t-e,this.getCoef(i-t)),l[t]=this.getCoef(i-t);for(let n=0;n<e;n++)for(let r=i-2*e-n;r>=0&&!(r<0);r-=e){let i=n;l[i]=a.add(this.getCoef(r+e),a.mul(l[i],t)),o.setCoef(r,l[i])}this.coef=o.coef}divByVanishing(e,t){if(this.degree()<e)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let a=this.Fr,i=new Polynomial(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new n.BigBuffer(this.length()*a.n8):new Uint8Array(this.length()*a.n8);for(let n=this.length()-1;n>=e;n--){let r=i.getCoef(n);a.eq(a.zero,r)||(i.setCoef(n,a.zero),i.setCoef(n-e,a.add(i.getCoef(n-e),a.mul(t,r))),this.setCoef(n-e,a.add(this.getCoef(n-e),r)))}return i}divByVanishing2(e,t){if(this.degree()<e)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let a=this.Fr,i=new Polynomial(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new n.BigBuffer(this.length()*a.n8):new Uint8Array(this.length()*a.n8);let r=this.length()-e,o=Math.floor(r/3),l=r-2*o;console.log(r),console.log(o+"  "+l);for(let n=0;n<3;n++){console.log("> Thread "+n);for(let r=0===n?l:o;r>0;r--){let s=r-1;0!==n&&(s+=(n-1)*o+l);let u=s+e,d=i.getCoef(u);a.eq(a.zero,d)||(i.setCoef(u,a.zero),i.setCoef(s,a.add(i.getCoef(s),a.mul(t,d))),this.setCoef(s,a.add(this.getCoef(s),d)),console.log(s+" <-- "+u))}}return this.print(),i}fastDivByVanishing(e){let t=this.Fr;for(let a=0;a<e.length;a++){let i=e[a][0],r=e[a][1];if(this.degree()<i)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let o=this.length()-i,l=Math.floor(o/5/i),s=l*i,u=o-5*s,d=new Polynomial(this.length()>32768?new n.BigBuffer(this.length()*t.n8):new Uint8Array(this.length()*t.n8),this.curve,this.logger),f=this.coef;this.coef=d.coef,d.coef=f;for(let e=0;e<5;e++){let a=(e+1)*s+u;for(let e=0;e<i;e++)this.setCoef(a+e-i,d.getCoef(a+e));for(let e=0;e<s-i;e++){let n=a-e-1,o=t.add(d.getCoef(n),t.mul(r,this.getCoef(n)));this.setCoef(n-i,o)}}let c=u;for(let e=0;e<i&&c;e++)this.setCoef(u-e-1,d.getCoef(u+i-e-1)),c--;for(let e=0;e<c;e++){let a=u-e-1,n=t.add(d.getCoef(a),t.mul(r,this.getCoef(a)));this.setCoef(a-i,n)}let m=[],h=t.one;for(let e=0;e<l;e++)h=t.mul(h,r);let g=t.one;for(let e=5;e>0;e--){let a=e-1,n=a*s+u;m[a]=[];for(let r=0;r<i;r++)m[a][r]=this.getCoef(n+r),5!==e&&(m[a][r]=t.add(m[a][r],t.mul(h,m[a+1][r])));g=t.mul(g,h)}for(let e=0;e<5;e++){let a=e*s+u,n=r,o=i-1,l=0===e?u:s;for(let s=0;s<l;s++){let l=a-s-1,u=t.add(this.getCoef(l),t.mul(n,m[e][o]));this.setCoef(l,u),0===o?(o=i-1,n=t.mul(n,r)):o--}}}}divByXSubValue(e){let t=this.length()>32768?new n.BigBuffer(this.length()*this.Fr.n8):new Uint8Array(this.length()*this.Fr.n8);t.set(this.Fr.zero,(this.length()-1)*this.Fr.n8),t.set(this.coef.slice((this.length()-1)*this.Fr.n8,this.length()*this.Fr.n8),(this.length()-2)*this.Fr.n8);for(let a=this.length()-3;a>=0;a--){let i=a*this.Fr.n8;t.set(this.Fr.add(this.coef.slice(i+this.Fr.n8,i+2*this.Fr.n8),this.Fr.mul(e,t.slice(i+this.Fr.n8,i+2*this.Fr.n8))),a*this.Fr.n8)}if(!this.Fr.eq(this.coef.slice(0,this.Fr.n8),this.Fr.mul(this.Fr.neg(e),t.slice(0,this.Fr.n8))))throw Error("Polynomial does not divide");this.coef=t}divZh(e,t=4){for(let t=0;t<e;t++){let e=t*this.Fr.n8;this.coef.set(this.Fr.neg(this.coef.slice(e,e+this.Fr.n8)),e)}let a=this.coef.byteLength/this.Fr.n8;for(let i=e;i<a;i++){let a=i*this.Fr.n8,n=this.Fr.sub(this.coef.slice((i-e)*this.Fr.n8,(i-e)*this.Fr.n8+this.Fr.n8),this.coef.slice(a,a+this.Fr.n8));if(this.coef.set(n,a),i>e*(t-1)-t&&!this.Fr.isZero(n))throw Error("Polynomial is not divisible")}return this}divByZerofier(e,t){let a=this.Fr,i=a.inv(t),n=a.neg(i),r=a.eq(a.one,n),o=a.eq(a.negone,n);if(!r)for(let t=0;t<e;t++){let e;let i=t*this.Fr.n8;e=o?a.neg(this.coef.slice(i,i+this.Fr.n8)):a.mul(n,this.coef.slice(i,i+this.Fr.n8)),this.coef.set(e,i)}r=a.eq(a.one,i),o=a.eq(a.negone,i);for(let t=e;t<this.length();t++){let n=t*this.Fr.n8,l=(t-e)*this.Fr.n8,s=this.Fr.sub(this.coef.slice(l,l+this.Fr.n8),this.coef.slice(n,n+this.Fr.n8));if(r||(s=o?a.neg(s):a.mul(i,s)),this.coef.set(s,n),t>this.length()-e-1&&!this.Fr.isZero(s))throw Error("Polynomial is not divisible")}return this}byX(){let e=this.length()+1>32768?new n.BigBuffer(this.coef.byteLength+this.Fr.n8):new Uint8Array(this.coef.byteLength+this.Fr.n8);e.set(this.Fr.zero,0),e.set(this.coef,this.Fr.n8),this.coef=e}static;async expX(e,t,a=!1){let i=e.Fr;if(t<1)throw Error("Compute a new polynomial to a zero or negative number is not allowed");if(1===t)return await Polynomial.fromEvaluations(e.coef,curve,e.logger);let r=a?e.degree():e.length()-1,o=r*t+1>32768?new n.BigBuffer((r*t+1)*i.n8):new Uint8Array((r*t+1)*i.n8);o.set(e.getCoef(0),0);for(let a=1;a<=r;a++){let n=a*i.n8,r=e.getCoef(a);o.set(r,n*t)}return new Polynomial(o,e.curve,e.logger)}split(e,t,a){if(e<1)throw Error(`Polynomials can't be split in ${e} parts`);if(1===e)return[this];if(0!==a.length&&a.length<e-1)throw Error(`Blinding factors length must be ${e-1}`);let i=(t+1)*this.Fr.n8,r=[],o=Math.ceil((this.degree()+1)*this.Fr.n8/i);if(o<e)for(let t=o;t<e;t++)r[t]=new Polynomial(new Uint8Array(this.Fr.n8),this.curve,this.logger);e=Math.min(e,o);for(let t=0;t<e;t++){let o=e-1===t,l=o?this.coef.byteLength-(e-1)*i:i+this.Fr.n8,s=l/this.Fr.n8>32768?new n.BigBuffer(l):new Uint8Array(l);r[t]=new Polynomial(s,this.curve,this.logger);let u=t*i,d=o?this.coef.byteLength:(t+1)*i;if(r[t].coef.set(this.coef.slice(u,d),0),o||r[t].coef.set(a[t],i),0!==t){let e=this.Fr.sub(r[t].coef.slice(0,this.Fr.n8),a[t-1]);r[t].coef.set(e,0)}o&&r[t].truncate()}return r}truncate(){let e=this.degree();if(e+1<this.coef.byteLength/this.Fr.n8){let t=e+1>32768?new n.BigBuffer((e+1)*this.Fr.n8):new Uint8Array((e+1)*this.Fr.n8);t.set(this.coef.slice(0,(e+1)*this.Fr.n8),0),this.coef=t}}static lagrangePolynomialInterpolation(e,t,a){let i=a.Fr,r=computeLagrangePolynomial(0);for(let t=1;t<e.length;t++)r.add(computeLagrangePolynomial(t));return r;function computeLagrangePolynomial(r){let o;for(let t=0;t<e.length;t++)if(t!==r){if(void 0===o){let r=e.length>32768?new n.BigBuffer(e.length*i.n8):new Uint8Array(e.length*i.n8);(o=new Polynomial(r,a)).setCoef(0,i.neg(e[t])),o.setCoef(1,i.one)}else o.byXSubValue(e[t])}let l=o.evaluate(e[r]);l=i.inv(l);let s=i.mul(t[r],l);return o.mulScalar(s),o}}static zerofierPolynomial(e,t){let a=t.Fr,i=e.length+1>32768?new n.BigBuffer((e.length+1)*a.n8):new Uint8Array((e.length+1)*a.n8),r=new Polynomial(i,t);r.setCoef(0,a.neg(e[0])),r.setCoef(1,a.one);for(let t=1;t<e.length;t++)r.byXSubValue(e[t]);return r}print(){let e=this.Fr,t="";for(let a=this.degree();a>=0;a--){let i=this.getCoef(a);!e.eq(e.zero,i)&&(e.isNegative(i)?t+=" - ":a!==this.degree()&&(t+=" + "),t+=e.toString(i),a>0&&(t+=a>1?"x^"+a:"x"))}console.log(t)}async multiExponentiation(e,t){let a=this.coef.byteLength/this.Fr.n8,i=e.slice(0,a*this.G1.F.n8*2),n=await this.Fr.batchFromMontgomery(this.coef),r=await this.G1.multiExpAffine(i,n,this.logger,t);return this.G1.toAffine(r)}};let Evaluations=class Evaluations{constructor(e,t,a){this.eval=e,this.curve=t,this.Fr=t.Fr,this.logger=a}static async fromPolynomial(e,t,a,i){let r=new n.BigBuffer(e.length()*t*a.Fr.n8);r.set(e.coef,0);let o=await a.Fr.fft(r);return new Evaluations(o,a,i)}getEvaluation(e){let t=e*this.Fr.n8;if(t+this.Fr.n8>this.eval.byteLength)throw Error("Evaluations.getEvaluation() out of bounds");return this.eval.slice(t,t+this.Fr.n8)}length(){let e=this.eval.byteLength/this.Fr.n8;if(e!==Math.floor(this.eval.byteLength/this.Fr.n8))throw Error("Polynomial evaluations buffer has incorrect size");return 0===e&&this.logger.warn("Polynomial has length zero"),e}};let{stringifyBigInts:z}=n.utils;async function plonk16Prove(e,t,a){let{fd:i,sections:r}=await c.readBinFile(t,"wtns",2,33554432,8388608);a&&a.debug("> Reading witness file");let o=await readHeader(i,r);a&&a.debug("> Reading zkey file");let{fd:l,sections:s}=await c.readBinFile(e,"zkey",2,33554432,8388608),u=await readHeader$1(l,s);if("plonk"!=u.protocol)throw Error("zkey file is not plonk");if(!n.Scalar.eq(u.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!=u.nVars-u.nAdditions)throw Error(`Invalid witness length. Circuit: ${u.nVars}, witness: ${o.nWitness}, ${u.nAdditions}`);let d=u.curve,f=d.Fr,m=d.Fr.n8,h=u.domainSize*m;a&&(a.debug("----------------------------"),a.debug("  PLONK PROVE SETTINGS"),a.debug(`  Curve:         ${d.name}`),a.debug(`  Circuit power: ${u.power}`),a.debug(`  Domain size:   ${u.domainSize}`),a.debug(`  Vars:          ${u.nVars}`),a.debug(`  Public vars:   ${u.nPublic}`),a.debug(`  Constraints:   ${u.nConstraints}`),a.debug(`  Additions:     ${u.nAdditions}`),a.debug("----------------------------")),a&&a.debug("> Reading witness file data");let g=await c.readSection(i,r,2);g.set(f.zero,0);let w=new n.BigBuffer(m*u.nAdditions),b={},p={},y={},v={},S=new Proof(d,a),C=new Keccak256Transcript(d);a&&a.debug("> Reading Section 3. Additions"),await calculateAdditions(),a&&a.debug("> Reading Section 12. Sigma1, Sigma2 & Sigma 3"),a&&a.debug("\xb7\xb7\xb7 Reading Sigma polynomials "),p.Sigma1=new Polynomial(new n.BigBuffer(h),d,a),p.Sigma2=new Polynomial(new n.BigBuffer(h),d,a),p.Sigma3=new Polynomial(new n.BigBuffer(h),d,a),await l.readToBuffer(p.Sigma1.coef,0,h,s[12][0].p),await l.readToBuffer(p.Sigma2.coef,0,h,s[12][0].p+5*h),await l.readToBuffer(p.Sigma3.coef,0,h,s[12][0].p+10*h),a&&a.debug("\xb7\xb7\xb7 Reading Sigma evaluations"),y.Sigma1=new Evaluations(new n.BigBuffer(4*h),d,a),y.Sigma2=new Evaluations(new n.BigBuffer(4*h),d,a),y.Sigma3=new Evaluations(new n.BigBuffer(4*h),d,a),await l.readToBuffer(y.Sigma1.eval,0,4*h,s[12][0].p+h),await l.readToBuffer(y.Sigma2.eval,0,4*h,s[12][0].p+6*h),await l.readToBuffer(y.Sigma3.eval,0,4*h,s[12][0].p+11*h),a&&a.debug("> Reading Section 14. Powers of Tau");let F=await c.readSection(l,s,14),E=[];for(let e=1;e<=u.nPublic;e++){let t=g.slice(e*f.n8,e*f.n8+f.n8);E.push(n.Scalar.fromRprLE(t))}a&&a.debug(""),a&&a.debug("> ROUND 1"),await round1(),a&&a.debug("> ROUND 2"),await round2(),a&&a.debug("> ROUND 3"),await round3(),a&&a.debug("> ROUND 4"),await round4(),a&&a.debug("> ROUND 5"),await round5(),await l.close(),await i.close();let B=S.toObjectProof(!1);return B.protocol="plonk",B.curve=d.name,a&&a.debug("PLONK PROVER FINISHED"),{proof:z(B),publicSignals:z(E)};async function calculateAdditions(){a&&a.debug("\xb7\xb7\xb7 Computing additions");let e=await c.readSection(l,s,3),t=8+2*m;for(let i=0;i<u.nAdditions;i++){a&&0!==i&&i%1e5==0&&a.debug(`    addition ${i}/${u.nAdditions}`);let n=i*t,r=readUInt32(e,n);n+=4;let o=readUInt32(e,n);n+=4;let l=e.slice(n,n+m);n+=m;let s=e.slice(n,n+m),d=getWitness(r),c=getWitness(o),h=f.add(f.mul(l,d),f.mul(s,c));w.set(h,m*i)}}function readUInt32(e,t){let a=e.slice(t,t+4),i=new DataView(a.buffer,a.byteOffset,a.byteLength);return i.getUint32(0,!0)}function getWitness(e){return e<u.nVars-u.nAdditions?g.slice(e*m,e*m+m):e<u.nVars?w.slice((e-(u.nVars-u.nAdditions))*m,(e-(u.nVars-u.nAdditions))*m+m):d.Fr.zero}async function round1(){v.b=[];for(let e=1;e<=11;e++)v.b[e]=d.Fr.random();a&&a.debug("> Computing A, B, C wire polynomials"),await computeWirePolynomials(),a&&a.debug("> Computing A, B, C MSM");let e=await p.A.multiExponentiation(F,"A"),t=await p.B.multiExponentiation(F,"B"),i=await p.C.multiExponentiation(F,"C");return S.addPolynomial("A",e),S.addPolynomial("B",t),S.addPolynomial("C",i),0}async function computeWirePolynomials(){a&&a.debug("\xb7\xb7\xb7 Reading data from zkey file"),b.A=new n.BigBuffer(h),b.B=new n.BigBuffer(h),b.C=new n.BigBuffer(h);let e=await c.readSection(l,s,4),t=await c.readSection(l,s,5),i=await c.readSection(l,s,6);for(let a=0;a<u.nConstraints;a++){let n=a*m,r=4*a,o=readUInt32(e,r);b.A.set(getWitness(o),n);let l=readUInt32(t,r);b.B.set(getWitness(l),n);let s=readUInt32(i,r);b.C.set(getWitness(s),n)}if(b.A=await f.batchToMontgomery(b.A),b.B=await f.batchToMontgomery(b.B),b.C=await f.batchToMontgomery(b.C),a&&a.debug("\xb7\xb7\xb7 Computing A ifft"),p.A=await Polynomial.fromEvaluations(b.A,d,a),a&&a.debug("\xb7\xb7\xb7 Computing B ifft"),p.B=await Polynomial.fromEvaluations(b.B,d,a),a&&a.debug("\xb7\xb7\xb7 Computing C ifft"),p.C=await Polynomial.fromEvaluations(b.C,d,a),a&&a.debug("\xb7\xb7\xb7 Computing A fft"),y.A=await Evaluations.fromPolynomial(p.A,4,d,a),a&&a.debug("\xb7\xb7\xb7 Computing B fft"),y.B=await Evaluations.fromPolynomial(p.B,4,d,a),a&&a.debug("\xb7\xb7\xb7 Computing C fft"),y.C=await Evaluations.fromPolynomial(p.C,4,d,a),p.A.blindCoefficients([v.b[2],v.b[1]]),p.B.blindCoefficients([v.b[4],v.b[3]]),p.C.blindCoefficients([v.b[6],v.b[5]]),p.A.degree()>=u.domainSize+2)throw Error("A Polynomial is not well calculated");if(p.B.degree()>=u.domainSize+2)throw Error("B Polynomial is not well calculated");if(p.C.degree()>=u.domainSize+2)throw Error("C Polynomial is not well calculated")}async function round2(){a&&a.debug("> Computing challenges beta and gamma"),C.reset(),C.addPolCommitment(u.Qm),C.addPolCommitment(u.Ql),C.addPolCommitment(u.Qr),C.addPolCommitment(u.Qo),C.addPolCommitment(u.Qc),C.addPolCommitment(u.S1),C.addPolCommitment(u.S2),C.addPolCommitment(u.S3);for(let e=0;e<u.nPublic;e++)C.addScalar(b.A.slice(e*m,e*m+m));C.addPolCommitment(S.getPolynomial("A")),C.addPolCommitment(S.getPolynomial("B")),C.addPolCommitment(S.getPolynomial("C")),v.beta=C.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.beta: "+f.toString(v.beta,16)),C.reset(),C.addScalar(v.beta),v.gamma=C.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.gamma: "+f.toString(v.gamma,16)),a&&a.debug("> Computing Z polynomial"),await computeZ(),a&&a.debug("> Computing Z MSM");let e=await p.Z.multiExponentiation(F,"Z");S.addPolynomial("Z",e)}async function computeZ(){a&&a.debug("\xb7\xb7\xb7 Computing Z evaluations");let e=new n.BigBuffer(h),t=new n.BigBuffer(h);e.set(f.one,0),t.set(f.one,0);let i=f.one;for(let a=0;a<u.domainSize;a++){let n=a*m,r=b.A.slice(n,n+m),o=b.B.slice(n,n+m),l=b.C.slice(n,n+m),s=f.mul(v.beta,i),d=f.add(r,s);d=f.add(d,v.gamma);let c=f.add(o,f.mul(u.k1,s));c=f.add(c,v.gamma);let h=f.add(l,f.mul(u.k2,s));h=f.add(h,v.gamma);let g=f.mul(d,f.mul(c,h)),w=f.add(r,f.mul(y.Sigma1.getEvaluation(4*a),v.beta));w=f.add(w,v.gamma);let p=f.add(o,f.mul(y.Sigma2.getEvaluation(4*a),v.beta));p=f.add(p,v.gamma);let S=f.add(l,f.mul(y.Sigma3.getEvaluation(4*a),v.beta));S=f.add(S,v.gamma);let C=f.mul(w,f.mul(p,S));g=f.mul(e.slice(n,n+m),g),e.set(g,(a+1)%u.domainSize*m),C=f.mul(t.slice(n,n+m),C),t.set(C,(a+1)%u.domainSize*m),i=f.mul(i,f.w[u.power])}t=await f.batchInverse(t);for(let a=0;a<u.domainSize;a++){let i=a*m,n=f.mul(e.slice(i,i+m),t.slice(i,i+m));e.set(n,i)}if(b.Z=e,!f.eq(e.slice(0,m),f.one))throw Error("Copy constraints does not match");if(a&&a.debug("\xb7\xb7\xb7 Computing Z ifft"),p.Z=await Polynomial.fromEvaluations(b.Z,d,a),a&&a.debug("\xb7\xb7\xb7 Computing Z fft"),y.Z=await Evaluations.fromPolynomial(p.Z,4,d,a),p.Z.blindCoefficients([v.b[9],v.b[8],v.b[7]]),p.Z.degree()>=u.domainSize+3)throw Error("Z Polynomial is not well calculated");delete b.Z}async function round3(){a&&a.debug("> Computing challenge alpha"),C.reset(),C.addScalar(v.beta),C.addScalar(v.gamma),C.addPolCommitment(S.getPolynomial("Z")),v.alpha=C.getChallenge(),v.alpha2=f.square(v.alpha),a&&a.debug("\xb7\xb7\xb7 challenges.alpha: "+f.toString(v.alpha,16)),a&&a.debug("> Computing T polynomial"),await computeT(),a&&a.debug("> Computing T MSM");let e=await p.T1.multiExponentiation(F,"T1"),t=await p.T2.multiExponentiation(F,"T2"),i=await p.T3.multiExponentiation(F,"T3");S.addPolynomial("T1",e),S.addPolynomial("T2",t),S.addPolynomial("T3",i)}async function computeT(){a&&a.debug(`\xb7\xb7\xb7 Reading sections 8, 9, 7, 10, 11. Q selectors`),y.QL=new Evaluations(new n.BigBuffer(4*h),d,a),y.QR=new Evaluations(new n.BigBuffer(4*h),d,a),y.QM=new Evaluations(new n.BigBuffer(4*h),d,a),y.QO=new Evaluations(new n.BigBuffer(4*h),d,a),y.QC=new Evaluations(new n.BigBuffer(4*h),d,a),await l.readToBuffer(y.QL.eval,0,4*h,s[8][0].p+h),await l.readToBuffer(y.QR.eval,0,4*h,s[9][0].p+h),await l.readToBuffer(y.QM.eval,0,4*h,s[7][0].p+h),await l.readToBuffer(y.QO.eval,0,4*h,s[10][0].p+h),await l.readToBuffer(y.QC.eval,0,4*h,s[11][0].p+h),y.Lagrange=new Evaluations(new n.BigBuffer(4*h*u.nPublic),d,a);for(let e=0;e<u.nPublic;e++)await l.readToBuffer(y.Lagrange.eval,e*h*4,4*h,s[13][0].p+5*e*h+h);b.T=new n.BigBuffer(4*h),b.Tz=new n.BigBuffer(4*h),a&&a.debug("\xb7\xb7\xb7 Computing T evaluations");let e=f.one;for(let t=0;t<4*u.domainSize;t++){a&&0!==t&&t%1e5==0&&a.debug(`      T evaluation ${t}/${4*u.domainSize}`);let i=y.A.getEvaluation(t),n=y.B.getEvaluation(t),r=y.C.getEvaluation(t),o=y.Z.getEvaluation(t),l=y.Z.getEvaluation((4*u.domainSize+4+t)%(4*u.domainSize)),s=y.QM.getEvaluation(t),d=y.QL.getEvaluation(t),c=y.QR.getEvaluation(t),h=y.QO.getEvaluation(t),g=y.QC.getEvaluation(t),w=y.Sigma1.getEvaluation(t),p=y.Sigma2.getEvaluation(t),S=y.Sigma3.getEvaluation(t),C=f.add(v.b[2],f.mul(v.b[1],e)),F=f.add(v.b[4],f.mul(v.b[3],e)),E=f.add(v.b[6],f.mul(v.b[5],e)),B=f.square(e),x=f.add(f.add(f.mul(v.b[7],B),f.mul(v.b[8],e)),v.b[9]),P=f.mul(e,f.w[u.power]),L=f.square(P),A=f.add(f.add(f.mul(v.b[7],L),f.mul(v.b[8],P)),v.b[9]),T=f.zero;for(let e=0;e<u.nPublic;e++){let a=4*e*u.domainSize+t,i=y.Lagrange.getEvaluation(a),n=b.A.slice(e*m,(e+1)*m);T=f.sub(T,f.mul(i,n))}let[_,G]=MulZ.mul2(i,n,C,F,t%4,f);_=f.mul(_,s),G=f.mul(G,s),_=f.add(_,f.mul(i,d)),G=f.add(G,f.mul(C,d)),_=f.add(_,f.mul(n,c)),G=f.add(G,f.mul(F,c)),_=f.add(_,f.mul(r,h)),G=f.add(G,f.mul(E,h)),_=f.add(_,T),_=f.add(_,g);let R=f.mul(v.beta,e),z=i;z=f.add(z,R),z=f.add(z,v.gamma);let U=n;U=f.add(U,f.mul(R,u.k1)),U=f.add(U,v.gamma);let k=r;k=f.add(k,f.mul(R,u.k2)),k=f.add(k,v.gamma);let[I,O]=MulZ.mul4(z,U,k,o,C,F,E,x,t%4,f);I=f.mul(I,v.alpha),O=f.mul(O,v.alpha);let $=i;$=f.add($,f.mul(v.beta,w)),$=f.add($,v.gamma);let V=n;V=f.add(V,f.mul(v.beta,p)),V=f.add(V,v.gamma);let q=r;q=f.add(q,f.mul(v.beta,S)),q=f.add(q,v.gamma);let[Q,Z]=MulZ.mul4($,V,q,l,C,F,E,A,t%4,f);Q=f.mul(Q,v.alpha),Z=f.mul(Z,v.alpha);let M=f.sub(o,f.one);M=f.mul(M,y.Lagrange.getEvaluation(t)),M=f.mul(M,v.alpha2);let W=f.mul(x,y.Lagrange.getEvaluation(t));W=f.mul(W,v.alpha2);let H=f.add(f.sub(f.add(_,I),Q),M),N=f.add(f.sub(f.add(G,O),Z),W);b.T.set(H,t*m),b.Tz.set(N,t*m),e=f.mul(e,f.w[u.power+2])}if(a&&a.debug("\xb7\xb7\xb7 Computing T ifft"),p.T=await Polynomial.fromEvaluations(b.T,d,a),a&&a.debug("\xb7\xb7\xb7 Computing T / ZH"),p.T.divZh(u.domainSize,4),a&&a.debug("\xb7\xb7\xb7 Computing Tz ifft"),p.Tz=await Polynomial.fromEvaluations(b.Tz,d,a),p.T.add(p.Tz),p.T.degree()>=3*u.domainSize+6)throw Error("T Polynomial is not well calculated");a&&a.debug("\xb7\xb7\xb7 Computing T1, T2, T3 polynomials"),p.T1=new Polynomial(new n.BigBuffer((u.domainSize+1)*m),d,a),p.T2=new Polynomial(new n.BigBuffer((u.domainSize+1)*m),d,a),p.T3=new Polynomial(new n.BigBuffer((u.domainSize+6)*m),d,a),p.T1.coef.set(p.T.coef.slice(0,h),0),p.T2.coef.set(p.T.coef.slice(h,2*h),0),p.T3.coef.set(p.T.coef.slice(2*h,3*h+6*m),0),p.T1.setCoef(u.domainSize,v.b[10]);let t=f.sub(p.T2.getCoef(0),v.b[10]);p.T2.setCoef(0,t),p.T2.setCoef(u.domainSize,v.b[11]);let i=f.sub(p.T3.getCoef(0),v.b[11]);p.T3.setCoef(0,i)}async function round4(){a&&a.debug("> Computing challenge xi"),C.reset(),C.addScalar(v.alpha),C.addPolCommitment(S.getPolynomial("T1")),C.addPolCommitment(S.getPolynomial("T2")),C.addPolCommitment(S.getPolynomial("T3")),v.xi=C.getChallenge(),v.xiw=f.mul(v.xi,f.w[u.power]),a&&a.debug("\xb7\xb7\xb7 challenges.xi: "+f.toString(v.xi,16)),S.addEvaluation("eval_a",p.A.evaluate(v.xi)),S.addEvaluation("eval_b",p.B.evaluate(v.xi)),S.addEvaluation("eval_c",p.C.evaluate(v.xi)),S.addEvaluation("eval_s1",p.Sigma1.evaluate(v.xi)),S.addEvaluation("eval_s2",p.Sigma2.evaluate(v.xi)),S.addEvaluation("eval_zw",p.Z.evaluate(v.xiw))}async function round5(){a&&a.debug("> Computing challenge v"),C.reset(),C.addScalar(v.xi),C.addScalar(S.getEvaluation("eval_a")),C.addScalar(S.getEvaluation("eval_b")),C.addScalar(S.getEvaluation("eval_c")),C.addScalar(S.getEvaluation("eval_s1")),C.addScalar(S.getEvaluation("eval_s2")),C.addScalar(S.getEvaluation("eval_zw")),v.v=[],v.v[1]=C.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.v: "+f.toString(v.v[1],16));for(let e=2;e<6;e++)v.v[e]=f.mul(v.v[e-1],v.v[1]);a&&a.debug("> Computing linearisation polynomial R(X)"),await computeR(),a&&a.debug("> Computing opening proof polynomial Wxi(X) polynomial"),p.Wxi=new Polynomial(new n.BigBuffer(h+6*m),d,a),p.Wxi.add(p.R),p.Wxi.add(p.A,v.v[1]),p.Wxi.add(p.B,v.v[2]),p.Wxi.add(p.C,v.v[3]),p.Wxi.add(p.Sigma1,v.v[4]),p.Wxi.add(p.Sigma2,v.v[5]),p.Wxi.subScalar(f.mul(v.v[1],S.evaluations.eval_a)),p.Wxi.subScalar(f.mul(v.v[2],S.evaluations.eval_b)),p.Wxi.subScalar(f.mul(v.v[3],S.evaluations.eval_c)),p.Wxi.subScalar(f.mul(v.v[4],S.evaluations.eval_s1)),p.Wxi.subScalar(f.mul(v.v[5],S.evaluations.eval_s2)),p.Wxi.divByZerofier(1,v.xi),a&&a.debug("> Computing opening proof polynomial Wxiw(X) polynomial"),computeWxiw(),a&&a.debug("> Computing Wxi, Wxiw MSM");let e=await p.Wxi.multiExponentiation(F,"Wxi"),t=await p.Wxiw.multiExponentiation(F,"Wxiw");S.addPolynomial("Wxi",e),S.addPolynomial("Wxiw",t)}async function computeR(){let e=d.Fr;p.QL=new Polynomial(new n.BigBuffer(h),d,a),p.QR=new Polynomial(new n.BigBuffer(h),d,a),p.QM=new Polynomial(new n.BigBuffer(h),d,a),p.QO=new Polynomial(new n.BigBuffer(h),d,a),p.QC=new Polynomial(new n.BigBuffer(h),d,a),await l.readToBuffer(p.QL.coef,0,h,s[8][0].p),await l.readToBuffer(p.QR.coef,0,h,s[9][0].p),await l.readToBuffer(p.QM.coef,0,h,s[7][0].p),await l.readToBuffer(p.QO.coef,0,h,s[10][0].p),await l.readToBuffer(p.QC.coef,0,h,s[11][0].p),v.xin=v.xi;for(let t=0;t<u.power;t++)v.xin=e.square(v.xin);v.zh=e.sub(v.xin,e.one);let t=[],i=e.e(u.domainSize),r=e.one;for(let a=1;a<=Math.max(1,u.nPublic);a++)t[a]=e.div(e.mul(r,v.zh),e.mul(i,e.sub(v.xi,r))),r=e.mul(r,e.w[u.power]);let o=e.div(e.sub(v.xin,e.one),e.mul(i,e.sub(v.xi,e.one)));if(a){a.debug("Lagrange Evaluations: ");for(let i=1;i<t.length;i++)a.debug(`L${i}(xi)=`+e.toString(t[i],16))}let f=e.zero;for(let a=0;a<E.length;a++){let i=e.e(E[a]);f=e.sub(f,e.mul(i,t[a+1]))}a&&a.debug("PI: "+e.toString(f,16));let c=e.mul(S.evaluations.eval_a,S.evaluations.eval_b),g=S.evaluations.eval_a,w=e.mul(v.beta,v.xi);g=e.add(g,w),g=e.add(g,v.gamma);let b=S.evaluations.eval_b;b=e.add(b,e.mul(w,u.k1)),b=e.add(b,v.gamma);let y=S.evaluations.eval_c;y=e.add(y,e.mul(w,u.k2)),y=e.add(y,v.gamma);let C=e.mul(e.mul(e.mul(g,b),y),v.alpha),F=S.evaluations.eval_a;F=e.add(F,e.mul(v.beta,S.evaluations.eval_s1)),F=e.add(F,v.gamma);let B=S.evaluations.eval_b;B=e.add(B,e.mul(v.beta,S.evaluations.eval_s2)),B=e.add(B,v.gamma);let x=e.mul(F,B);x=e.mul(x,S.evaluations.eval_zw),x=e.mul(x,v.alpha);let P=e.mul(o,v.alpha2);p.R=new Polynomial(new n.BigBuffer((u.domainSize+6)*m),d,a),p.R.add(p.QM,c),p.R.add(p.QL,S.evaluations.eval_a),p.R.add(p.QR,S.evaluations.eval_b),p.R.add(p.QO,S.evaluations.eval_c),p.R.add(p.QC),p.R.add(p.Z,C),p.R.sub(p.Sigma3,e.mul(x,v.beta)),p.R.add(p.Z,P);let L=Polynomial.fromPolynomial(p.T3,d,a);L.mulScalar(e.square(v.xin)),L.add(p.T2,v.xin),L.add(p.T1),L.mulScalar(v.zh),p.R.sub(L);let A=e.sub(f,e.mul(x,e.add(S.evaluations.eval_c,v.gamma)));A=e.sub(A,P),a&&a.debug("r0: "+e.toString(A,16)),p.R.addScalar(A)}async function computeWxiw(){p.Wxiw=Polynomial.fromPolynomial(p.Z,d,a),p.Wxiw.subScalar(S.evaluations.eval_zw),p.Wxiw.divByZerofier(1,v.xiw)}}let{unstringifyBigInts:U}=n.utils,{unstringifyBigInts:k}=n.utils;async function isValidPairing$1(e,t,a,i,n,r){let o=e.G1,l=e.Fr,s=t.Wxi;s=o.add(s,o.timesFr(t.Wxiw,a.u));let u=o.timesFr(t.Wxi,a.xi),d=l.mul(l.mul(a.u,a.xi),l.w[i.power]);u=o.add(u,o.timesFr(t.Wxiw,d)),u=o.add(u,r),u=o.sub(u,n);let f=await e.pairingEq(o.neg(s),i.X_2,u,e.G2.one);return f}let{unstringifyBigInts:I}=n.utils;function getFFlonkConstantConstraint(e,t){return[e,0,0,t.one,t.zero,t.zero,t.zero,t.zero]}function getFFlonkAdditionConstraint(e,t,a,i,n,r,o,l){return[e,t,a,i,n,r,o,l]}function getFFlonkMultiplicationConstraint(e,t,a,i,n,r,o,l,s){return[e,t,a,i,n,r,o,l]}let r1csConstraintProcessor=class r1csConstraintProcessor{constructor(e,t,a,i,n){this.Fr=e,this.logger=n,this.fnGetAdditionConstraint=a,this.fnGetMultiplicationConstraint=i}processR1csConstraint(e,t,a,i){this.normalizeLinearCombination(t),this.normalizeLinearCombination(a),this.normalizeLinearCombination(i);let n=this.getLinearCombinationType(t),r=this.getLinearCombinationType(a);if(0===n||0===r)return this.processR1csAdditionConstraint(e,i);if(1===n){let n=this.joinLinearCombinations(a,i,t[0]);return this.processR1csAdditionConstraint(e,n)}if(1!==r)return this.processR1csMultiplicationConstraint(e,t,a,i);{let n=this.joinLinearCombinations(t,i,a[0]);return this.processR1csAdditionConstraint(e,n)}}getLinearCombinationType(e){let t=this.Fr.zero,a=0,i=Object.keys(e);for(let n=0;n<i.length;n++)0n==e[i[n]]?delete e[i[n]]:0==i[n]?t=this.Fr.add(t,e[i[n]]):a++;return a>0?2:this.Fr.isZero(t)?0:1}normalizeLinearCombination(e){let t=Object.keys(e);for(let a=0;a<t.length;a++)this.Fr.isZero(e[t[a]])&&delete e[t[a]];return e}joinLinearCombinations(e,t,a){let i={};for(let t in e)void 0===i[t]?i[t]=this.Fr.mul(a,e[t]):i[t]=this.Fr.add(i[t],this.Fr.mul(a,e[t]));for(let e in t)void 0===i[e]?i[e]=t[e]:i[e]=this.Fr.add(i[e],t[e]);return this.normalizeLinearCombination(i)}reduceCoefs(e,t,a,i,n){let r={k:this.Fr.zero,signals:[],coefs:[]},o=[];for(let e in i)0==e?r.k=this.Fr.add(r.k,i[e]):0n!=i[e]&&o.push([Number(e),i[e]]);for(;o.length>n;){let i=o.shift(),n=o.shift(),r=e.nVars++,l=this.fnGetAdditionConstraint(i[0],n[0],r,this.Fr.neg(i[1]),this.Fr.neg(n[1]),this.Fr.zero,this.Fr.one,this.Fr.zero);t.push(l),a.push([i[0],n[0],i[1],n[1]]),o.push([r,this.Fr.one])}for(let e=0;e<o.length;e++)r.signals[e]=o[e][0],r.coefs[e]=o[e][1];for(;r.coefs.length<n;)r.signals.push(0),r.coefs.push(this.Fr.zero);return r}processR1csAdditionConstraint(e,t){let a=[],i=[],n=this.reduceCoefs(e,a,i,t,3),r=this.fnGetAdditionConstraint(n.signals[0],n.signals[1],n.signals[2],n.coefs[0],n.coefs[1],this.Fr.zero,n.coefs[2],n.k);return a.push(r),[a,i]}processR1csMultiplicationConstraint(e,t,a,i){let n=[],r=[],o=this.reduceCoefs(e,n,r,t,1),l=this.reduceCoefs(e,n,r,a,1),s=this.reduceCoefs(e,n,r,i,1),u=this.fnGetMultiplicationConstraint(o.signals[0],l.signals[0],s.signals[0],this.Fr.mul(o.coefs[0],l.k),this.Fr.mul(o.k,l.coefs[0]),this.Fr.mul(o.coefs[0],l.coefs[0]),this.Fr.neg(s.coefs[0]),this.Fr.sub(this.Fr.mul(o.k,l.k),s.k));return n.push(u),[n,r]}};let CPolynomial=class CPolynomial{constructor(e,t,a){this.n=e,this.polynomials=Array(e).fill(void 0),this.curve=t,this.Fr=t.Fr,this.G1=t.G1,this.logger=a}addPolynomial(e,t){if(e>this.n-1)throw Error("CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1");this.polynomials[e]=t}degree(){return Math.max(...this.polynomials.map((e,t)=>void 0===e?0:e.degree()*this.n+t))}getPolynomial(){let e=this.polynomials.map(e=>void 0===e?0:e.degree()),t=this.degree(),a=2**(log2(t-1)+1),i=this.Fr.n8,r=new Polynomial(new n.BigBuffer(a*i),this.curve,this.logger);for(let a=0;a<t;a++){let t=a*i,n=t*this.n;for(let o=0;o<this.n;o++)void 0!==this.polynomials[o]&&a<=e[o]&&r.coef.set(this.polynomials[o].coef.slice(t,t+i),n+o*i)}return r}async multiExponentiation(e,t){let a=this.getPolynomial(),i=a.coef.byteLength/this.Fr.n8,n=e.slice(0,i*this.G1.F.n8*2),r=await this.Fr.batchFromMontgomery(a.coef),o=await this.G1.multiExpAffine(n,r,this.logger,t);return this.G1.toAffine(o)}};let{stringifyBigInts:O}=n.utils;async function fflonkProve(e,t,a){a&&a.info("FFLONK PROVER STARTED"),a&&a.info("> Reading witness file");let{fd:i,sections:r}=await c.readBinFile(t,"wtns",2,33554432,8388608),o=await readHeader(i,r);a&&a.info("> Reading zkey file");let{fd:l,sections:s}=await c.readBinFile(e,"zkey",2,33554432,8388608),u=await readHeader$1(l,s);if(10!==u.protocolId)throw Error("zkey file is not fflonk");if(!n.Scalar.eq(u.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!==u.nVars-u.nAdditions)throw Error(`Invalid witness length. Circuit: ${u.nVars}, witness: ${o.nWitness}, ${u.nAdditions}`);let d=u.curve,f=d.Fr,m=d.Fr.n8,h=2*d.G1.F.n8,g=u.domainSize*m;a&&(a.info("----------------------------"),a.info("  FFLONK PROVE SETTINGS"),a.info(`  Curve:         ${d.name}`),a.info(`  Circuit power: ${u.power}`),a.info(`  Domain size:   ${u.domainSize}`),a.info(`  Vars:          ${u.nVars}`),a.info(`  Public vars:   ${u.nPublic}`),a.info(`  Constraints:   ${u.nConstraints}`),a.info(`  Additions:     ${u.nAdditions}`),a.info("----------------------------")),a&&a.info("> Reading witness file data");let w=await c.readSection(i,r,2);await i.close(),w.set(f.zero,0);let b=new n.BigBuffer(u.nAdditions*m),p={},y={},v={},S={},C={},F={},E=new Proof(d,a);a&&a.info("> Reading Section 3. Additions"),await calculateAdditions(),a&&a.info("> Reading Sections 12,13,14. Sigma1, Sigma2 & Sigma 3"),a&&a.info("\xb7\xb7\xb7 Reading Sigma polynomials "),y.Sigma1=new Polynomial(new n.BigBuffer(g),d,a),y.Sigma2=new Polynomial(new n.BigBuffer(g),d,a),y.Sigma3=new Polynomial(new n.BigBuffer(g),d,a),await l.readToBuffer(y.Sigma1.coef,0,g,s[12][0].p),await l.readToBuffer(y.Sigma2.coef,0,g,s[13][0].p),await l.readToBuffer(y.Sigma3.coef,0,g,s[14][0].p),a&&a.info("\xb7\xb7\xb7 Reading Sigma evaluations"),v.Sigma1=new Evaluations(new n.BigBuffer(4*g),d,a),v.Sigma2=new Evaluations(new n.BigBuffer(4*g),d,a),v.Sigma3=new Evaluations(new n.BigBuffer(4*g),d,a),await l.readToBuffer(v.Sigma1.eval,0,4*g,s[12][0].p+g),await l.readToBuffer(v.Sigma2.eval,0,4*g,s[13][0].p+g),await l.readToBuffer(v.Sigma3.eval,0,4*g,s[14][0].p+g),a&&a.info("> Reading Section 16. Powers of Tau");let B=new n.BigBuffer(16*u.domainSize*h);await l.readToBuffer(B,0,(9*u.domainSize+18)*h,s[16][0].p),globalThis.gc&&globalThis.gc(),a&&a.info(""),a&&a.info("> ROUND 1"),await round1(),delete y.T0,delete v.QL,delete v.QR,delete v.QM,delete v.QO,delete v.QC,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 2"),await round2(),delete p.A,delete p.B,delete p.C,delete v.A,delete v.B,delete v.C,delete v.Sigma1,delete v.Sigma2,delete v.Sigma3,delete v.lagrange1,delete v.Z,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 3"),await round3(),delete y.A,delete y.B,delete y.C,delete y.Z,delete y.T1,delete y.T2,delete y.Sigma1,delete y.Sigma2,delete y.Sigma3,delete y.QL,delete y.QR,delete y.QM,delete y.QC,delete y.QO,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 4"),await round4(),globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 5"),await round5(),delete y.C0,delete y.C1,delete y.C2,delete y.R1,delete y.R2,delete y.F,delete y.L,delete y.ZT,delete y.ZTS2,await l.close(),globalThis.gc&&globalThis.gc(),E.addEvaluation("inv",function(){let e=C.xi;for(let t=0;t<u.power;t++)e=f.square(e);S.zh=f.sub(e,f.one),function(e,t,a,i){let n=i.Fr,r=t.length,o=n.mul(n.e(r),n.exp(t[0],r-2));for(let i=0;i<r;i++){let l=t[(r-1)*i%r],s=n.sub(a,t[i]);e[["LiS0_"+(i+1)]]=n.mul(n.mul(o,l),s)}}(S,F.S0.h0w8,C.y,d),function(e,t,a,i){let n=i.Fr,r=t.length,o=n.mul(n.e(r),n.exp(t[0],r-2));for(let i=0;i<r;i++){let l=t[(r-1)*i%r],s=n.sub(a,t[i]);e[["LiS1_"+(i+1)]]=n.mul(n.mul(o,l),s)}}(S,F.S1.h1w4,C.y,d),function(e,t,a,i,n,r,o){let l=o.Fr,s=l.mul(l.e(3),t[0]),u=l.sub(n,r),d=l.mul(s,u);for(let a=0;a<3;a++){let n=t[2*a%3],r=l.sub(i,t[a]);e[["LiS2_"+(a+1)]]=l.mul(d,l.mul(n,r))}let f=l.mul(l.e(3),a[0]),c=l.sub(r,n);d=l.mul(f,c);for(let t=0;t<3;t++){let n=a[2*t%3],r=l.sub(i,a[t]);e[["LiS2_"+(t+1+3)]]=l.mul(d,l.mul(n,r))}}(S,F.S2.h2w3,F.S2.h3w3,C.y,C.xi,C.xiw,d);let t=Math.max(1,u.nPublic),a=f.one;for(let e=0;e<t;e++)S["Li_"+(e+1)]=f.mul(f.e(u.domainSize),f.sub(C.xi,a)),a=f.mul(a,f.w[u.power]);let i=f.one;for(let e of Object.values(S))if(Array.isArray(e))for(let t of e)i=f.mul(i,t);else i=f.mul(i,e);return f.inv(i)}());let x=E.toObjectProof();x.protocol="fflonk",x.curve=d.name;let P=[];for(let e=1;e<=u.nPublic;e++){let t=e*m,a=w.slice(t,t+m);P.push(n.Scalar.fromRprLE(a))}return a&&a.info("FFLONK PROVER FINISHED"),{proof:O(x),publicSignals:O(P)};async function calculateAdditions(){a&&a.info("\xb7\xb7\xb7 Computing additions");let e=await c.readSection(l,s,3),t=8+2*m;for(let i=0;i<u.nAdditions;i++){a&&0!==i&&i%1e5==0&&a.info(`    addition ${i}/${u.nAdditions}`);let n=i*t,r=readUInt32(e,n);n+=4;let o=readUInt32(e,n);n+=4;let l=e.slice(n,n+m);n+=m;let s=e.slice(n,n+m),d=getWitness(r),c=getWitness(o),h=f.add(f.mul(l,d),f.mul(s,c));b.set(h,m*i)}}function readUInt32(e,t){let a=e.slice(t,t+4),i=new DataView(a.buffer,a.byteOffset,a.byteLength);return i.getUint32(0,!0)}function getWitness(e){let t=u.nVars-u.nAdditions;if(e<t)return w.slice(e*m,e*m+m);if(e<u.nVars){let a=(e-t)*m;return b.slice(a,a+m)}return f.zero}async function round1(){C.b=[];for(let e=1;e<=9;e++)C.b[e]=f.random();a&&a.info("> Computing A, B, C wire polynomials"),await computeWirePolynomials(),a&&a.info("> Computing T0 polynomial"),await computeT0(),a&&a.info("> Computing C1 polynomial"),await computeC1(),a&&a.info("> Computing C1 multi exponentiation");let e=await y.C1.multiExponentiation(B,"C1");return E.addPolynomial("C1",e),0;async function computeWirePolynomials(){a&&a.info("\xb7\xb7\xb7 Reading data from zkey file"),p.A=new n.BigBuffer(g),p.B=new n.BigBuffer(g),p.C=new n.BigBuffer(g);let e=await c.readSection(l,s,4),t=await c.readSection(l,s,5),i=await c.readSection(l,s,6);for(let a=0;a<u.nConstraints;a++){let n=a*m,r=4*a,o=readUInt32(e,r);p.A.set(getWitness(o),n);let l=readUInt32(t,r);p.B.set(getWitness(l),n);let s=readUInt32(i,r);p.C.set(getWitness(s),n)}if(p.A.set(C.b[1],g-64),p.A.set(C.b[2],g-32),p.B.set(C.b[3],g-64),p.B.set(C.b[4],g-32),p.C.set(C.b[5],g-64),p.C.set(C.b[6],g-32),p.A=await f.batchToMontgomery(p.A),p.B=await f.batchToMontgomery(p.B),p.C=await f.batchToMontgomery(p.C),a&&a.info("\xb7\xb7\xb7 Computing A ifft"),y.A=await Polynomial.fromEvaluations(p.A,d,a),a&&a.info("\xb7\xb7\xb7 Computing B ifft"),y.B=await Polynomial.fromEvaluations(p.B,d,a),a&&a.info("\xb7\xb7\xb7 Computing C ifft"),y.C=await Polynomial.fromEvaluations(p.C,d,a),a&&a.info("\xb7\xb7\xb7 Computing A fft"),v.A=await Evaluations.fromPolynomial(y.A,4,d,a),a&&a.info("\xb7\xb7\xb7 Computing B fft"),v.B=await Evaluations.fromPolynomial(y.B,4,d,a),a&&a.info("\xb7\xb7\xb7 Computing C fft"),v.C=await Evaluations.fromPolynomial(y.C,4,d,a),y.A.degree()>=u.domainSize)throw Error("A Polynomial is not well calculated");if(y.B.degree()>=u.domainSize)throw Error("B Polynomial is not well calculated");if(y.C.degree()>=u.domainSize)throw Error("C Polynomial is not well calculated")}async function computeT0(){a&&a.info(`\xb7\xb7\xb7 Reading sections 7, 8, 9, 10, 11. Q selectors`),v.QL=new Evaluations(new n.BigBuffer(4*g),d,a),v.QR=new Evaluations(new n.BigBuffer(4*g),d,a),v.QM=new Evaluations(new n.BigBuffer(4*g),d,a),v.QO=new Evaluations(new n.BigBuffer(4*g),d,a),v.QC=new Evaluations(new n.BigBuffer(4*g),d,a),await l.readToBuffer(v.QL.eval,0,4*g,s[7][0].p+g),await l.readToBuffer(v.QR.eval,0,4*g,s[8][0].p+g),await l.readToBuffer(v.QM.eval,0,4*g,s[9][0].p+g),await l.readToBuffer(v.QO.eval,0,4*g,s[10][0].p+g),await l.readToBuffer(v.QC.eval,0,4*g,s[11][0].p+g);let e=await c.readSection(l,s,15);v.lagrange1=new Evaluations(e,d,a),p.T0=new n.BigBuffer(4*g),a&&a.info("\xb7\xb7\xb7 Computing T0 evaluations");for(let e=0;e<4*u.domainSize;e++){a&&0!==e&&e%1e5==0&&a.info(`      T0 evaluation ${e}/${4*u.domainSize}`);let t=v.A.getEvaluation(e),i=v.B.getEvaluation(e),n=v.C.getEvaluation(e),r=v.QL.getEvaluation(e),o=v.QR.getEvaluation(e),l=v.QM.getEvaluation(e),s=v.QO.getEvaluation(e),d=v.QC.getEvaluation(e),c=f.zero;for(let t=0;t<u.nPublic;t++){let a=5*t*u.domainSize+u.domainSize+e,i=v.lagrange1.getEvaluation(a),n=p.A.slice(t*m,(t+1)*m);c=f.sub(c,f.mul(i,n))}let h=f.mul(t,r),g=f.mul(i,o),w=f.mul(f.mul(t,i),l),b=f.mul(n,s),y=f.add(h,f.add(g,f.add(w,f.add(b,f.add(d,c)))));p.T0.set(y,e*m)}if(a&&a.info("buffer T0: "+p.T0.byteLength/m),a&&a.info("\xb7\xb7\xb7 Computing T0 ifft"),y.T0=await Polynomial.fromEvaluations(p.T0,d,a),a&&a.info("T0 length: "+y.T0.length()),a&&a.info("T0 degree: "+y.T0.degree()),a&&a.info("\xb7\xb7\xb7 Computing T0 / ZH"),y.T0.divByZerofier(u.domainSize,f.one),y.T0.degree()>=2*u.domainSize-2)throw Error(`T0 Polynomial is not well calculated (degree is ${y.T0.degree()} and must be less than ${2*u.domainSize+2}`);delete p.T0}async function computeC1(){let e=new CPolynomial(4,d,a);if(e.addPolynomial(0,y.A),e.addPolynomial(1,y.B),e.addPolynomial(2,y.C),e.addPolynomial(3,y.T0),y.C1=e.getPolynomial(),y.C1.degree()>=8*u.domainSize-8)throw Error("C1 Polynomial is not well calculated")}}async function round2(){a&&a.info("> Computing challenges beta and gamma");let e=new Keccak256Transcript(d);e.addPolCommitment(u.C0);for(let t=0;t<u.nPublic;t++)e.addScalar(p.A.slice(t*m,t*m+m));e.addPolCommitment(E.getPolynomial("C1")),C.beta=e.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.beta: "+f.toString(C.beta)),e.reset(),e.addScalar(C.beta),C.gamma=e.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.gamma: "+f.toString(C.gamma)),a&&a.info("> Computing Z polynomial"),await computeZ(),a&&a.info("> Computing T1 polynomial"),await computeT1(),a&&a.info("> Computing T2 polynomial"),await computeT2(),a&&a.info("> Computing C2 polynomial"),await computeC2(),a&&a.info("> Computing C2 multi exponentiation");let t=await y.C2.multiExponentiation(B,"C2");return E.addPolynomial("C2",t),0;async function computeZ(){a&&a.info("\xb7\xb7\xb7 Computing Z evaluations");let e=new n.BigBuffer(g),t=new n.BigBuffer(g);e.set(f.one,0),t.set(f.one,0);let i=f.one;for(let n=0;n<u.domainSize;n++){a&&0!==n&&n%1e5==0&&a.info(`    Z evaluation ${n}/${u.domainSize}`);let r=n*m,o=f.mul(C.beta,i),l=p.A.slice(r,r+m);l=f.add(l,o),l=f.add(l,C.gamma);let s=p.B.slice(r,r+m);s=f.add(s,f.mul(u.k1,o)),s=f.add(s,C.gamma);let d=p.C.slice(r,r+m);d=f.add(d,f.mul(u.k2,o)),d=f.add(d,C.gamma);let c=f.mul(l,f.mul(s,d)),h=p.A.slice(r,r+m);h=f.add(h,f.mul(C.beta,v.Sigma1.getEvaluation(4*n))),h=f.add(h,C.gamma);let g=p.B.slice(r,r+m);g=f.add(g,f.mul(C.beta,v.Sigma2.getEvaluation(4*n))),g=f.add(g,C.gamma);let w=p.C.slice(r,r+m);w=f.add(w,f.mul(C.beta,v.Sigma3.getEvaluation(4*n))),w=f.add(w,C.gamma);let b=f.mul(h,f.mul(g,w));c=f.mul(e.slice(r,r+m),c),e.set(c,(n+1)%u.domainSize*m),b=f.mul(t.slice(r,r+m),b),t.set(b,(n+1)%u.domainSize*m),i=f.mul(i,f.w[u.power])}t=await f.batchInverse(t);for(let a=0;a<u.domainSize;a++){let i=a*m,n=f.mul(e.slice(i,i+m),t.slice(i,i+m));e.set(n,i)}if(p.Z=e,!f.eq(e.slice(0,m),f.one))throw Error("Copy constraints does not match");if(a&&a.info("\xb7\xb7\xb7 Computing Z ifft"),y.Z=await Polynomial.fromEvaluations(p.Z,d,a),a&&a.info("\xb7\xb7\xb7 Computing Z fft"),v.Z=await Evaluations.fromPolynomial(y.Z,4,d,a),y.Z.blindCoefficients([C.b[9],C.b[8],C.b[7]]),y.Z.degree()>=u.domainSize+3)throw Error("Z Polynomial is not well calculated");delete p.Z}async function computeT1(){a&&a.info("\xb7\xb7\xb7 Computing T1 evaluations"),p.T1=new n.BigBuffer(2*g),p.T1z=new n.BigBuffer(2*g);let e=f.one;for(let t=0;t<2*u.domainSize;t++){a&&0!==t&&t%1e5==0&&a.info(`    T1 evaluation ${t}/${4*u.domainSize}`);let i=f.square(e),n=v.Z.getEvaluation(2*t),r=f.add(f.add(f.mul(C.b[7],i),f.mul(C.b[8],e)),C.b[9]),o=v.lagrange1.getEvaluation(u.domainSize+2*t),l=f.mul(f.sub(n,f.one),o),s=f.mul(r,o);p.T1.set(l,t*m),p.T1z.set(s,t*m),e=f.mul(e,f.w[u.power+1])}if(a&&a.info("\xb7\xb7\xb7 Computing T1 ifft"),y.T1=await Polynomial.fromEvaluations(p.T1,d,a),y.T1.divByZerofier(u.domainSize,f.one),a&&a.info("\xb7\xb7\xb7 Computing T1z ifft"),y.T1z=await Polynomial.fromEvaluations(p.T1z,d,a),y.T1.add(y.T1z),y.T1.degree()>=u.domainSize+2)throw Error("T1 Polynomial is not well calculated");delete p.T1,delete p.T1z,delete y.T1z}async function computeT2(){a&&a.info("\xb7\xb7\xb7 Computing T2 evaluations"),p.T2=new n.BigBuffer(4*g),p.T2z=new n.BigBuffer(4*g);let e=f.one;for(let t=0;t<4*u.domainSize;t++){a&&0!==t&&t%1e5==0&&a.info(`    T2 evaluation ${t}/${4*u.domainSize}`);let i=f.square(e),n=f.mul(e,f.w[u.power]),r=f.square(n),o=v.A.getEvaluation(t),l=v.B.getEvaluation(t),s=v.C.getEvaluation(t),d=v.Z.getEvaluation(t),c=v.Z.getEvaluation((4*u.domainSize+4+t)%(4*u.domainSize)),h=f.add(f.add(f.mul(C.b[7],i),f.mul(C.b[8],e)),C.b[9]),g=f.add(f.add(f.mul(C.b[7],r),f.mul(C.b[8],n)),C.b[9]),w=v.Sigma1.getEvaluation(t),b=v.Sigma2.getEvaluation(t),y=v.Sigma3.getEvaluation(t),S=f.mul(C.beta,e),F=f.add(o,S);F=f.add(F,C.gamma);let E=f.add(l,f.mul(S,u.k1));E=f.add(E,C.gamma);let B=f.add(s,f.mul(S,u.k2));B=f.add(B,C.gamma);let x=f.mul(f.mul(f.mul(F,E),B),d),P=f.mul(f.mul(f.mul(F,E),B),h),L=f.add(o,f.mul(C.beta,w));L=f.add(L,C.gamma);let A=f.add(l,f.mul(C.beta,b));A=f.add(A,C.gamma);let T=f.add(s,f.mul(C.beta,y));T=f.add(T,C.gamma);let _=f.mul(f.mul(f.mul(L,A),T),c),G=f.mul(f.mul(f.mul(L,A),T),g),R=f.sub(x,_),z=f.sub(P,G);p.T2.set(R,t*m),p.T2z.set(z,t*m),e=f.mul(e,f.w[u.power+2])}if(a&&a.info("\xb7\xb7\xb7 Computing T2 ifft"),y.T2=await Polynomial.fromEvaluations(p.T2,d,a),a&&a.info("\xb7\xb7\xb7 Computing T2 / ZH"),y.T2.divByZerofier(u.domainSize,f.one),a&&a.info("\xb7\xb7\xb7 Computing T2z ifft"),y.T2z=await Polynomial.fromEvaluations(p.T2z,d,a),y.T2.add(y.T2z),y.T2.degree()>=3*u.domainSize)throw Error("T2 Polynomial is not well calculated");delete p.T2,delete p.T2z,delete y.T2z}async function computeC2(){let e=new CPolynomial(3,d,a);if(e.addPolynomial(0,y.Z),e.addPolynomial(1,y.T1),e.addPolynomial(2,y.T2),y.C2=e.getPolynomial(),y.C2.degree()>=9*u.domainSize)throw Error("C2 Polynomial is not well calculated")}}async function round3(){a&&a.info("> Computing challenge xi");let e=new Keccak256Transcript(d);e.addScalar(C.gamma),e.addPolCommitment(E.getPolynomial("C2")),C.xiSeed=e.getChallenge();let t=f.square(C.xiSeed);F.w8=[],F.w8[0]=f.one;for(let e=1;e<8;e++)F.w8[e]=f.mul(F.w8[e-1],u.w8);F.w4=[],F.w4[0]=f.one;for(let e=1;e<4;e++)F.w4[e]=f.mul(F.w4[e-1],u.w4);F.w3=[],F.w3[0]=f.one,F.w3[1]=u.w3,F.w3[2]=f.square(u.w3),F.S0={},F.S0.h0w8=[],F.S0.h0w8[0]=f.mul(t,C.xiSeed);for(let e=1;e<8;e++)F.S0.h0w8[e]=f.mul(F.S0.h0w8[0],F.w8[e]);F.S1={},F.S1.h1w4=[],F.S1.h1w4[0]=f.square(F.S0.h0w8[0]);for(let e=1;e<4;e++)F.S1.h1w4[e]=f.mul(F.S1.h1w4[0],F.w4[e]);F.S2={},F.S2.h2w3=[],F.S2.h2w3[0]=f.mul(F.S1.h1w4[0],t),F.S2.h2w3[1]=f.mul(F.S2.h2w3[0],F.w3[1]),F.S2.h2w3[2]=f.mul(F.S2.h2w3[0],F.w3[2]),F.S2.h3w3=[],F.S2.h3w3[0]=f.mul(F.S2.h2w3[0],u.wr),F.S2.h3w3[1]=f.mul(F.S2.h3w3[0],F.w3[1]),F.S2.h3w3[2]=f.mul(F.S2.h3w3[0],F.w3[2]),C.xi=f.mul(f.square(F.S2.h2w3[0]),F.S2.h2w3[0]),a&&a.info("\xb7\xb7\xb7 challenges.xi: "+f.toString(C.xi)),y.QL=new Polynomial(new n.BigBuffer(g),d,a),y.QR=new Polynomial(new n.BigBuffer(g),d,a),y.QM=new Polynomial(new n.BigBuffer(g),d,a),y.QO=new Polynomial(new n.BigBuffer(g),d,a),y.QC=new Polynomial(new n.BigBuffer(g),d,a),await l.readToBuffer(y.QL.coef,0,g,s[7][0].p),await l.readToBuffer(y.QR.coef,0,g,s[8][0].p),await l.readToBuffer(y.QM.coef,0,g,s[9][0].p),await l.readToBuffer(y.QO.coef,0,g,s[10][0].p),await l.readToBuffer(y.QC.coef,0,g,s[11][0].p),a&&a.info("\xb7\xb7\xb7 Computing evaluations"),E.addEvaluation("ql",y.QL.evaluate(C.xi)),E.addEvaluation("qr",y.QR.evaluate(C.xi)),E.addEvaluation("qm",y.QM.evaluate(C.xi)),E.addEvaluation("qo",y.QO.evaluate(C.xi)),E.addEvaluation("qc",y.QC.evaluate(C.xi)),E.addEvaluation("s1",y.Sigma1.evaluate(C.xi)),E.addEvaluation("s2",y.Sigma2.evaluate(C.xi)),E.addEvaluation("s3",y.Sigma3.evaluate(C.xi)),E.addEvaluation("a",y.A.evaluate(C.xi)),E.addEvaluation("b",y.B.evaluate(C.xi)),E.addEvaluation("c",y.C.evaluate(C.xi)),E.addEvaluation("z",y.Z.evaluate(C.xi)),C.xiw=f.mul(C.xi,f.w[u.power]),E.addEvaluation("zw",y.Z.evaluate(C.xiw)),E.addEvaluation("t1w",y.T1.evaluate(C.xiw)),E.addEvaluation("t2w",y.T2.evaluate(C.xiw))}async function round4(){a&&a.info("> Computing challenge alpha");let e=new Keccak256Transcript(d);e.addScalar(C.xiSeed),e.addScalar(E.getEvaluation("ql")),e.addScalar(E.getEvaluation("qr")),e.addScalar(E.getEvaluation("qm")),e.addScalar(E.getEvaluation("qo")),e.addScalar(E.getEvaluation("qc")),e.addScalar(E.getEvaluation("s1")),e.addScalar(E.getEvaluation("s2")),e.addScalar(E.getEvaluation("s3")),e.addScalar(E.getEvaluation("a")),e.addScalar(E.getEvaluation("b")),e.addScalar(E.getEvaluation("c")),e.addScalar(E.getEvaluation("z")),e.addScalar(E.getEvaluation("zw")),e.addScalar(E.getEvaluation("t1w")),e.addScalar(E.getEvaluation("t2w")),C.alpha=e.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.alpha: "+f.toString(C.alpha)),a&&a.info("> Reading C0 polynomial"),y.C0=new Polynomial(new n.BigBuffer(8*g),d,a),await l.readToBuffer(y.C0.coef,0,8*g,s[17][0].p),a&&a.info("> Computing R0 polynomial"),function(){if(y.R0=Polynomial.lagrangePolynomialInterpolation([F.S0.h0w8[0],F.S0.h0w8[1],F.S0.h0w8[2],F.S0.h0w8[3],F.S0.h0w8[4],F.S0.h0w8[5],F.S0.h0w8[6],F.S0.h0w8[7]],[y.C0.evaluate(F.S0.h0w8[0]),y.C0.evaluate(F.S0.h0w8[1]),y.C0.evaluate(F.S0.h0w8[2]),y.C0.evaluate(F.S0.h0w8[3]),y.C0.evaluate(F.S0.h0w8[4]),y.C0.evaluate(F.S0.h0w8[5]),y.C0.evaluate(F.S0.h0w8[6]),y.C0.evaluate(F.S0.h0w8[7])],d),y.R0.degree()>7)throw Error("R0 Polynomial is not well calculated")}(),a&&a.info("> Computing R1 polynomial"),function(){if(y.R1=Polynomial.lagrangePolynomialInterpolation([F.S1.h1w4[0],F.S1.h1w4[1],F.S1.h1w4[2],F.S1.h1w4[3]],[y.C1.evaluate(F.S1.h1w4[0]),y.C1.evaluate(F.S1.h1w4[1]),y.C1.evaluate(F.S1.h1w4[2]),y.C1.evaluate(F.S1.h1w4[3])],d),y.R1.degree()>3)throw Error("R1 Polynomial is not well calculated")}(),a&&a.info("> Computing R2 polynomial"),function(){if(y.R2=Polynomial.lagrangePolynomialInterpolation([F.S2.h2w3[0],F.S2.h2w3[1],F.S2.h2w3[2],F.S2.h3w3[0],F.S2.h3w3[1],F.S2.h3w3[2]],[y.C2.evaluate(F.S2.h2w3[0]),y.C2.evaluate(F.S2.h2w3[1]),y.C2.evaluate(F.S2.h2w3[2]),y.C2.evaluate(F.S2.h3w3[0]),y.C2.evaluate(F.S2.h3w3[1]),y.C2.evaluate(F.S2.h3w3[2])],d),y.R2.degree()>5)throw Error("R2 Polynomial is not well calculated")}(),a&&a.info("> Computing F polynomial"),await computeF(),a&&a.info("> Computing W1 multi exponentiation");let t=await y.F.multiExponentiation(B,"W1");return E.addPolynomial("W1",t),0;async function computeF(){a&&a.info("\xb7\xb7\xb7 Computing F polynomial"),y.F=Polynomial.fromPolynomial(y.C0,d,a),y.F.sub(y.R0),y.F.divByZerofier(8,C.xi);let e=Polynomial.fromPolynomial(y.C1,d,a);e.sub(y.R1),e.mulScalar(C.alpha),e.divByZerofier(4,C.xi);let t=Polynomial.fromPolynomial(y.C2,d,a);if(t.sub(y.R2),t.mulScalar(f.square(C.alpha)),t.divByZerofier(3,C.xi),t.divByZerofier(3,C.xiw),y.F.add(e),y.F.add(t),y.F.degree()>=9*u.domainSize-6)throw Error("F Polynomial is not well calculated")}}async function round5(){a&&a.info("> Computing challenge y");let e=new Keccak256Transcript(d);e.addScalar(C.alpha),e.addPolCommitment(E.getPolynomial("W1")),C.y=e.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.y: "+f.toString(C.y)),a&&a.info("> Computing L polynomial"),await computeL(),a&&a.info("> Computing ZTS2 polynomial"),await computeZTS2();let t=y.ZTS2.evaluate(C.y);t=f.inv(t),y.L.mulScalar(t);let i=Polynomial.fromCoefficientsArray([f.neg(C.y),f.one],d);a&&a.info("> Computing W' = L / ZTS2 polynomial");let n=y.L.divBy(i);if(n.degree()>0)throw Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${n.degree()} and should be 0`);if(y.L.degree()>=9*u.domainSize-1)throw Error("Degree of L(X)/(ZTS2(y)(X-y)) is not correct");a&&a.info("> Computing W' multi exponentiation");let r=await y.L.multiExponentiation(B,"W2");return E.addPolynomial("W2",r),0;async function computeL(){a&&a.info("\xb7\xb7\xb7 Computing L polynomial");let e=y.R0.evaluate(C.y),t=y.R1.evaluate(C.y),i=y.R2.evaluate(C.y),n=f.sub(C.y,F.S0.h0w8[0]);for(let e=1;e<8;e++)n=f.mul(n,f.sub(C.y,F.S0.h0w8[e]));let r=f.sub(C.y,F.S1.h1w4[0]);for(let e=1;e<4;e++)r=f.mul(r,f.sub(C.y,F.S1.h1w4[e]));let o=f.sub(C.y,F.S2.h2w3[0]);for(let e=1;e<3;e++)o=f.mul(o,f.sub(C.y,F.S2.h2w3[e]));for(let e=0;e<3;e++)o=f.mul(o,f.sub(C.y,F.S2.h3w3[e]));let l=f.mul(r,o),s=f.mul(C.alpha,f.mul(n,o)),c=f.mul(f.square(C.alpha),f.mul(n,r));S.denH1=r,S.denH2=o,y.L=Polynomial.fromPolynomial(y.C0,d,a),y.L.subScalar(e),y.L.mulScalar(l);let m=Polynomial.fromPolynomial(y.C1,d,a);m.subScalar(t),m.mulScalar(s);let h=Polynomial.fromPolynomial(y.C2,d,a);h.subScalar(i),h.mulScalar(c),y.L.add(m),y.L.add(h),a&&a.info("> Computing ZT polynomial"),await computeZT();let g=y.ZT.evaluate(C.y);if(y.F.mulScalar(g),y.L.sub(y.F),y.L.degree()>=9*u.domainSize)throw Error("L Polynomial is not well calculated");delete p.L}async function computeZT(){y.ZT=Polynomial.zerofierPolynomial([F.S0.h0w8[0],F.S0.h0w8[1],F.S0.h0w8[2],F.S0.h0w8[3],F.S0.h0w8[4],F.S0.h0w8[5],F.S0.h0w8[6],F.S0.h0w8[7],F.S1.h1w4[0],F.S1.h1w4[1],F.S1.h1w4[2],F.S1.h1w4[3],F.S2.h2w3[0],F.S2.h2w3[1],F.S2.h2w3[2],F.S2.h3w3[0],F.S2.h3w3[1],F.S2.h3w3[2]],d)}async function computeZTS2(){y.ZTS2=Polynomial.zerofierPolynomial([F.S1.h1w4[0],F.S1.h1w4[1],F.S1.h1w4[2],F.S1.h1w4[3],F.S2.h2w3[0],F.S2.h2w3[1],F.S2.h2w3[2],F.S2.h3w3[0],F.S2.h3w3[1],F.S2.h3w3[2]],d)}}}let{unstringifyBigInts:$}=n.utils,{unstringifyBigInts:V}=n.utils;function checkValueBelongToField(e,t){return n.Scalar.lt(t,e.r)}function checkEvaluationIsValid(e,t){return checkValueBelongToField(e,n.Scalar.fromRprLE(t))}async function computeLagrangeEvaluations(e,t,a){let i=e.Fr,r=Math.max(1,a.nPublic),o=new n.BigBuffer(r*i.n8),l=new n.BigBuffer(r*i.n8),s=i.one;for(let e=0;e<r;e++){let n=e*i.n8;o.set(i.mul(s,t.zh),n),l.set(i.mul(i.e(a.domainSize),i.sub(t.xi,s)),n),s=i.mul(s,a.w)}l=await i.batchInverse(l);let u=[];for(let e=0;e<r;e++){let t=e*i.n8;u[e+1]=i.mul(o.slice(t,t+i.n8),l.slice(t,t+i.n8))}return u}async function isValidPairing(e,t,a,i,n,r,o){let l=e.G1,s=l.timesFr(t.polynomials.W2,a.y);s=l.add(l.sub(l.sub(n,r),o),s);let u=e.G2.one,d=t.polynomials.W2,f=i.X_2;return await e.pairingEq(l.neg(s),u,d,f)}function computeLagrangeLiSi(e,t,a,i){let n=i.Fr,r=e.length,o=n.sub(n.exp(t,r),a),l=n.mul(n.e(r),n.exp(e[0],r-2)),s=[];for(let a=0;a<r;a++){let i=e[(r-1)*a%r],u=n.sub(t,e[a]);s[a]=n.div(o,n.mul(n.mul(l,i),u))}return s}let{unstringifyBigInts:q}=n.utils;t.tt=P}}]);